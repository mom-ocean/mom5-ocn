[{"directory": "src/mom5/ocean_bgc", "namelists": [{"namelist": "ocean_ibgc_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "do_ideal", "description": " If true, then do ideal_n and suntan. This does not require any other part of the model. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_po4", "description": " If true, then do the non-Fe-limited P cycle, iPO4 and iDOP. If either this or do_po4f is true, PO4_pre and chl will be calculated as well. If both do_po4 and do_po4f are true, po4 will be the master variable, unless bgc_felim is true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_gasses", "description": " If true, then do the gases Dissolved Inorganic Carbon (iDIC) and oxygen (iO2). Requires that do_po4 and/or do_po4f be true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_carbon_comp", "description": " If true, then do the dissolved inorganic carbon component tracers, Saturation DIC (iDIC_sat) and preformed DIC (iDIC_pre). Requires that do_po4 and/or do_po4f be true, and that do_gasses be true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_radiocarbon", "description": " If true, then do the radiocarbon tracers (iDI14C and iDO14C). Requires that do_po4 and/or do_po4f be true, and that do_gasses be true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_bgc_felim", "description": " If true, then use PO4f as the master variable for biogeochemical calculations (gases, PO4_pre, chl, isotopes). Requires that do_PO4f be true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_po4f", "description": " If true, then do the Fe-limited P cycle, with iFe, iPO4f and DOP. If either this or do_po4 is true, PO4_pre and chl will be calculated as well. If both do_po4 and do_po4f are true, po4 will be the master variable, unless do_bgc_felim is true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_isio4", "description": " If true, then do silica cycle and silicon isotopes, iSiO4 and i30SiO4. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_no3_iso", "description": " If true, then do NO3 isotopes, i15NO3, iN18O3 and iDO15N. Requires that do_po4 and/or do_po4f be true. "}], "filename": "src/mom5/ocean_bgc/ocean_ibgc.F90"}]}, {"directory": "src/mom5/ocean_blobs", "namelists": [{"namelist": "ocean_blob_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " Writes additional diagnostic data to fms.out.  This also controls debug output for the other related blob modules. Default is debug_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "really_debug", "description": " Be careful what you wish for, this outputs A LOT of diagnostics to standard out Default is debug_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " When global sum outputs are done there is additional computational expense to ensure that they are bitwise the same across an arbitrary number of processors. However, for debugging purposes, it can be useful for global sums to be the same.  Note, that this differs from bitwise_reproduction in that it do_bitwise_exact_sum only applies to the mpp_global_sum diagnostic. Note that this flag controls the output for all associated blob modules. Default is do_bitwise_exact_sum=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bitwise_reproduction", "description": " There is additional cost involved in ensuring that results are reproducable across an arbitrary number of processors and across restarts. Bitwise reproduction is a very memory intensive operation and should only be used for debugging.  For bitwise_reproduction=.true. We need to process blobs and their histories in the same relative order regardless of domain decomposition and restarts. To do so, we save the \"history\" of each blob subcycle is saved to a number of arrays (which can be a very memory intensive process) and process them in order. Note that this flag controls reproducability for all associated blob modules. Bitwise reproducibility is only possible with the appropriate compiler flags AND when the simulation is run on hardware that is capable of producing bitwise reproduction. Default is bitwise_reproduction=.false. "}, {"default": "1.0e3", "units": "kg", "type_": "real", "name": "blob_small_mass", "description": " Will delete blobs of mass less than blob_small_mass. Note that this variable is for all associated blob modules.  The deletion of blobs is a conservative action, any mass/tracer fields that are nonzero have the remaining properties transferred back to the Eulerian system.  So, in principle, blob_small_mass can actually be a relatively large number, and the model will remain conservative.  It has been found in certain test cases (with very low tracer values) that setting blob_small_mass to be very small (i.e. <1e2) that roundoff error can cause non-trivial errors.  So, it is recommended that blob_small_mass be no smaller than than 1e3 kg (which is approximately 1.0m**3 -- a very small blob Default is blob_small_mass=1.e3 "}, {"default": "0.7", "units": null, "type_": "real", "name": "max_prop_thickness", "description": null}], "filename": "src/mom5/ocean_blobs/ocean_blob.F90"}, {"namelist": "ocean_blob_diag_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "blob_diagnostics", "description": " Logical as to whether diagnostics should be saved or not. Default is .false. "}, {"default": "\"blob_diag_table\"", "units": null, "type_": "character(len=31)", "name": "diag_table", "description": " Name of file to look for blob diagnostic information. Default is \"blob_diag_table\" "}, {"default": "2000000", "units": null, "type_": "integer", "name": "dump_num", "description": " The number of entried to keep in memory before writing them to file.  The higher the number, the more memory that the module will take up, but, it should lower the frequency of IO operations. Default is 2000000 "}, {"default": "1", "units": null, "type_": "integer", "name": "frequency", "description": " The frequency (in number of E system time steps) that blob diagnostics should be saved. Default is 1 "}], "filename": "src/mom5/ocean_blobs/ocean_blob_diag.F90"}, {"namelist": "ocean_blob_dynamic_bottom_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is use_this_module=.false. "}, {"default": "'BS_RK3(2)'", "units": null, "type_": "character(len=10)", "name": "update_method", "description": null}, {"default": "1.0e-4", "units": null, "type_": "real", "name": "blob_overflow_mu", "description": " Frictional dissipation rate used for calculating initial properties of bottom blobs.  Corresponds to mu in Campin and Goosse (1999).  Units are 1/s. Default is blob_overflow_mu=1.0e-4 "}, {"default": "0.3333", "units": null, "type_": "real", "name": "blob_overflow_delta", "description": " Fraction of a grid cell participating in an overflow event. Corresponds to delta in Campin and Goosse (1999).  Dimensionless. Default is blob_overflow_mu=1.0e-4 "}, {"default": "3.0e-3", "units": null, "type_": "real", "name": "drag", "description": " Coefficient of drag used for bottom stress drag. Corresponds to Cd in Price and Baringer (1994). Dimensionless. Default is drag=3.0e-3 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "enforce_big_blobs", "description": null}, {"default": "5.0e-8", "units": null, "type_": "real", "name": "det_param", "description": " The detrainment parameter (kg m^2/s). Corresponds to Gamma in the notes. Default is det_param=5.0e-8  "}, {"default": "1.0e-3", "units": null, "type_": "real", "name": "max_detrainment", "description": " The Maximum allowable detrainment velocity (m/s). Default is max_detrainment=1.0e-3 "}, {"default": "0.01", "units": null, "type_": "real", "name": "rel_error", "description": " Relative error for the RK scheme (dimensionless). A smaller number is more accurate, but, is more computationally expensive. Corresponds to zeta* in the notes. Must be 0<rel_error<=1.0 Default is rel_error=0.01 "}, {"default": "0.8", "units": null, "type_": "real", "name": "safety_factor", "description": " Safety factor for the RK scheme (dimensionless). A smaller number should reduce the number of rejected steps, but, decreases the locally extrapolated step.  Corresponds to varrho in the notes. Must be 0<safety_factor<=1.0 Default is safety_factor=0.8 "}, {"default": "9.0", "units": null, "type_": "real", "name": "minstep", "description": " Minimum step size (in seconds) for a blob. Default is minstep=9.0 "}, {"default": "50.0", "units": null, "type_": "real", "name": "first_step", "description": null}, {"default": "1.0", "units": null, "type_": "real", "name": "elastic", "description": " The elasticity of a blob's collision with the topography.  Corresponds to epsilon in the notes. Should have values 0<=elastic<=1.0 Values greater than 1 would be super-elastic, and values less than 0 would send the blob in the opposite direction than it should be going in. Default is elastic=1.0 "}, {"default": "1", "units": null, "type_": "integer", "name": "min_do_levels", "description": " Minimum number of deep ocean levels for overflows to be considered.  That is, how many k levels lower should the deep ocean water column be than the shelf/shallow ocean column.  Value must be greater than 0. Default is min_do_levels=1 "}, {"default": "0.01", "units": null, "type_": "real", "name": "rho_threshold", "description": " The density difference required before a blob is formed.  rho_threshold must be greater than zero. Default is rho_threshold=0.01 "}, {"default": ".true.", "units": null, "type_": "logical", "name": "accept_free_blobs", "description": null}, {"default": "10.0", "units": null, "type_": "real", "name": "large_speed", "description": " A value for error checking.  If the speed of a blob exceeds large_speed in any of x,y,z then a warning flag is raised. Default is large_speed=10.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "no_rotation", "description": " Sets the coriolis parameter to zero regardless of latitude Default is no_rotation=.false. "}, {"default": "0.8", "units": null, "type_": "real", "name": "critical_richardson", "description": " The critical Richardson number for the entrainment velocity.  Default is based on Price and Baringer (1994). Default is critical_richardson=0.8 "}, {"default": "100.0", "units": null, "type_": "real", "name": "blob_height", "description": null}], "filename": "src/mom5/ocean_blobs/ocean_blob_dynamic_bottom.F90"}, {"namelist": "ocean_blob_dynamic_free_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is use_this_module=.false. "}, {"default": "1.0e-5", "units": null, "type_": "real", "name": "rayleigh_drag_new", "description": " Rayleigh drag coefficient (1/s) for new blobs that are formed due to the vertical instability criterion.  Corresponds to alpha in the notes. Default is rayleigh_drag_new=1.0e-5 "}, {"default": "1.0e-7", "units": null, "type_": "real", "name": "rayleigh_drag_bot", "description": " Rayleigh drag coefficient (1/s) for bottom blobs that become free blobs.  Corresponds to alpha in the notes. Default is rayleigh_drag_bot=1.0e-7 "}, {"default": "'CK_RK5(4)'", "units": null, "type_": "character(len=10)", "name": "update_method", "description": " Decide which method to use to integrate the blobs.  Choices are 'BS_RK3(2)' or 'CK_RK5(4)' for the Bogaki-Shampine or Cash-Karp methods respectively. Default is update_method='CK_RK5(4) "}, {"default": "0.01", "units": null, "type_": "real", "name": "rel_error", "description": " Relative error for the RK scheme (dimensionless). A smaller number is more accurate, but, is more computationally expensive. Corresponds to zeta* in the notes. Must be 0<rel_error<=1.0 Default is rel_error=0.01 "}, {"default": "0.8", "units": null, "type_": "real", "name": "safety_factor", "description": " Safety factor for the RK scheme (dimensionless). A smaller number should reduce the number of rejected steps, but, decreases the locally extrapolated step.  Corresponds to varrho in the notes. Must be 0<safety_factor<=1.0 Default is safety_factor=0.8 "}, {"default": "9.0", "units": null, "type_": "real", "name": "minstep", "description": " Minimum step size (in seconds) for a blob. Default is minstep=9.0 "}, {"default": "50.0", "units": null, "type_": "real", "name": "first_step", "description": null}, {"default": "1.0", "units": null, "type_": "real", "name": "size_fact", "description": " An Adjustment for blob size, 0<size_fact<=1.0 Corresponds to Lambda in the notes. Default is size_fact=1.0 "}, {"default": "5.e-8", "units": null, "type_": "real", "name": "det_param", "description": " The detrainment parameter (kg m^2/s). Corresponds to Gamma in the notes. Default is det_param=5.0e-8 "}, {"default": "1.e-3", "units": null, "type_": "real", "name": "max_detrainment", "description": " The Maximum allowable detrainment velocity (m/s). Default is max_detrainment=1.0e-3 "}, {"default": "-1.e-15", "units": null, "type_": "real", "name": "bv_freq_threshold", "description": " The buoyancy frequency threshold at which the scheme will start to create blobs, i.e. blobs will be formed when N^2<bv_freq_threshold Default is bv_freq_threshold=-1.0e-15 "}, {"default": ".true.", "units": null, "type_": "logical", "name": "full_N2", "description": " Whether to use the buoyancy frequency calculated from the combined E and L system (true) or, from the E system only (false). Default is full_N2=.true. "}, {"default": "10.0", "units": null, "type_": "real", "name": "large_speed", "description": " A value for error checking.  If the speed of a blob exceeds large_speed in any of x,y,z then a warning flag is raised. Default is large_speed=10.0 "}], "filename": "src/mom5/ocean_blobs/ocean_blob_dynamic_free.F90"}, {"namelist": "ocean_blob_static_bottom_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "overflow_no_return", "description": " When .false. creates return blobs to replicate the original Campin and Goosse scheme.  When .true. only creates blobs that sink.  See further overflow_one_return "}, {"default": ".false.", "units": null, "type_": "logical", "name": "overflow_one_return", "description": " Creates a single return blob when .true.  Cannot be .true. when overflow_no_return is also .true. "}, {"default": "1.0e-4", "units": "1/s", "type_": "real", "name": "blob_overflow_mu", "description": " Frictional dissipation used in blob_overflow scheme Default is blob_overflow_mu=1.0e-4 "}, {"default": "0.3333", "units": null, "type_": "real", "name": "blob_overflow_delta", "description": " Fraction of grid cell participating in overflow Valid values are 0<=delta<=1 Default is blob_overflow_delta=1/3 "}, {"default": "0.01", "units": "m/s", "type_": "real", "name": "blob_overflow_umax", "description": " Maximum downslope speed allowed for overflow Default is blob_overflow_umax=0.01 "}], "filename": "src/mom5/ocean_blobs/ocean_blob_static_bottom.F90"}, {"namelist": "ocean_blob_static_free_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "blob_ncon_like", "description": " If true, will use NCon-like formulation. Default blob_ncon_like = .true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "blob_diff_like", "description": " If true, will use the diffusion-like formulation. Default is \"blob_diff_like=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "blob_swap_like", "description": " If true, will use the swap-like formulation. Default is blob_switch_like=.false. "}, {"default": "7", "units": null, "type_": "integer", "name": "ncon_blob", "description": " The number of times that the water column is checked and adjusted for instability. "}], "filename": "src/mom5/ocean_blobs/ocean_blob_static_free.F90"}]}, {"directory": "src/mom5/ocean_core", "namelists": [{"namelist": "ocean_advection_velocity_nml", "items": [{"default": "-1.0", "units": "meter/sec", "type_": "real", "name": "max_advection_velocity", "description": " This is a check value used to determine if the time steps will result in linearly stable advection.  If set to a number < 0, then model will estimate the value as a function of maximum grid size. Note that this time step check is not rigorous, and it depends on the details of the advection scheme.  Nonetheless, it provides some useful warning for setting the time steps in the model. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "inflow_nboundary", "description": " For adding an inflow velocity from the northern boundary. Default is inflow_nboundary=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_advection_velocity", "description": " For reading in a file with specified zonal, meridional, and vertical components to the advective velocity. The file should have velocity at the east face of T-cell, north face, and bottom, just as on a C-grid.  The units should be m/s for each component.  MOM then multiplies but the appropriate thickness and density factors to generate transport for use in the model. Default read_advection_velocity=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_advection_transport", "description": " For reading in a file with specified zonal, meridional, and vertical components to the advection transport. The file should have transport at the east face of T-cell, north face, and bottom, just as on a C-grid.  The units should be (kg/m^3)*(m^2/sec) for horz components, and (kg/m^3)*(m/sec) for vertical component.  MOM then uses these fields directly to initialize uhrho_et, vhrho_nt, and wrho_bt. Default read_advection_transport=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "constant_advection_velocity", "description": " When reading in the advection velocity components, we may choose to keep them constant in time.  This facilitates idealized tests of tracer advection. Default constant_advection_velocity=.false. "}], "filename": "src/mom5/ocean_core/ocean_advection_velocity.F90"}, {"namelist": "ocean_barotropic_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency", "description": " If true, will not integrate the barotropic fields. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_eta_ic", "description": " To initialize eta_t to zero. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_eta_tendency", "description": " To maintain deta_dt at zero.  For debugging. Default zero_eta_t=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_eta_t", "description": " To maintain eta_t at zero, but to allow other fields to evolve. For debugging.  Default zero_eta_t=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_eta_u", "description": " To maintain eta_u at zero, but to allow other fields to evolve. For debugging.  Default zero_eta_u=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_forcing_bt", "description": " Will set to zero all of the terms forcing the barotropic velocity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_nonlinear_forcing_bt", "description": " Will set to zero the nonlinear forcing terms, leaving only the smf and bmf terms to force the barotropic velocity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_coriolis_bt", "description": " Will set to zero the Coriolis parameter for purpooses of computing the barotropic momentum equation. This option is for testing alone. Default zero_coriolis_bt = .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ideal_initial_eta", "description": " To initialize eta_t to an ideal profile.  This option overrides all other initialization that may have occurred. Default=.false. "}, {"default": "5.0", "units": "metre", "type_": "real", "name": "ideal_initial_eta_amplitude", "description": " Amplitude for initializing eta with an ideal profile. Default ideal_initial_eta_amplitude = 5.0 "}, {"default": "100e3", "units": "metre", "type_": "real", "name": "ideal_initial_eta_xwidth", "description": " Width in x-direction for sine-wave profile. Default xwidth=100e3 "}, {"default": "100e3", "units": "metre", "type_": "real", "name": "ideal_initial_eta_ywidth", "description": " Width in y-direction for sine-wave profile. Default ywidth=100e3 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "truncate_eta", "description": " To truncate the surface height so to ensure positive thickness within the top cell. This method will not conserve volume or tracer. It is coded for cases when conservation is not critical but wish to run GEOPOTENTIAL models w/ large free surface height deviations, such as when running with tides and very fine vertical resolution. The preferred approach is to use zstar or pstart vertical coordinates. Default truncate_eta = .false.. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_truncate", "description": " For verbose printout on truncate_eta "}, {"default": ".20", "units": "dimensionless", "type_": "real", "name": "frac_crit_cell_height", "description": " When use GEOPOTENTIAL vertical coordinate, the top model tracer grid cell has thickness dzt(i,j,1) = dzt(1) + eta_t(i,j). 0 < frac_crit_cell_height <= 1 sets the fraction of dzt(1) that is allowed prior to bringing the model down due to overly small dzt(i,j,1). Default frac_crit_cell_height=0.20. "}, {"default": "5.0", "units": "meter", "type_": "real", "name": "eta_max", "description": " The maximum positive eta_t allowed when truncate_eta is true. Default eta_max = 5.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " Print out lots of diagnostics of use for debugging. Default debug_this_module=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For brief or full printout on initialization Default verbose_init=.true. "}, {"default": "-1", "units": null, "type_": "integer", "name": "diag_step", "description": " Frequency for output of ascii barotropic diagnostics. Setting diag_step=1 will compute diagnostics each time step and print to stdout.  This setting is useful when developing a model in order to examine various budgets and stability issues. But when running production, one should set diag_step to a mucch larger number in order to reduce i/o and model cost.  Default diag_step=-1, which means will not compute any of the online diagnostics. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tidal_forcing_m2", "description": " Forces from lunar M2 tidal constituent. Default tidal_forcing_m2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tidal_forcing_8", "description": " Forces from 8 lunar and solar tidal constituents. Default tidal_forcing_8=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tidal_forcing_ideal", "description": " For ideal tidal forcing, which has a bump configuration. Default tidal_forcing_ideal=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "geoid_forcing", "description": " For modifying the geoid, implemented as a time independent tidal forcing. Need to read in a file to obtain the offset geoid profile. Default geoid_forcing=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. Default do_bitwise_exact_sum=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_eta_t_bt_laplacian", "description": " For spatially smoothing the eta_t field at each barotropic time step using a Laplacian operator.  This option may not be necessary when pred_corr_gamma > 0.0, since the predictor-corrector approach has dissipation from pred_corr_gamma > 0.0.  Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid.  This option is only applicable for DEPTH_BASED vertical coordinates. Default smooth_eta_t_bt_laplacian=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_eta_t_bt_biharmonic", "description": " For spatially smoothing the eta_t field at each barotropic time step using a biharmonic operator. May not be necessary when pred_corr_gamma > 0.0, since predictor-corrector has dissipation from pred_corr_gamma > 0.0. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Applicable just for DEPTH_BASED vertical coordinates. WARNING: this operator is NOT positive definite, and so can produce spurious extrema.  It is not generally recommended just for this reason. Default smooth_eta_t_bt_laplacian=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_eta_t_laplacian", "description": " For spatially smoothing the eta_t field on the big time step by using a laplacian operator. For compatibility and global conservation, must also introduce a mixing to the thickness weighted tracer concentration in the k=1 cell. Applicable just for DEPTH_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Default mooth_eta_t_laplacian=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_eta_t_biharmonic", "description": " For spatially smoothing the eta_t field on the big time step by using a biharmonic operator. For compatibility and global conservation, must also introduce a mixing to the thickness weighted tracer concentration in the k=1 cell. Applicable just for DEPTH_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. WARNING: This operator is NOT positive definite, and so can produce spurious extrema.  It is not recommended just for this reason. Default smooth_eta_t_biharmonic=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_eta_diag_laplacian", "description": " For spatially smoothing the diagnosed eta_t field using a laplacian operator. This option is used for PRESSURE_BASED vertical coordinates, in which case the free surface is diagnosed rather than prognosed. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Default smooth_eta_diag_laplacian=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_eta_diag_biharmonic", "description": " For spatially smoothing the diagnosed eta_t field using a biharmonic operator.  This option is used for PRESSURE_BASED vertical coordinates, in which case the free surface is diagnosed rather than prognosed. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Default smooth_eta_diag_biharmonic=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_anompb_bt_laplacian", "description": " For spatially smoothing anomalous pbot_t at each barotropic time step using a Laplacian operator.  May not be necessary when pred_corr_gamma > 0.0, since predictor-corrector has dissipation from pred_corr_gamma > 0.0.  This option is applicable just for PRESSURE_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Default smooth_anompb_bt_laplacian=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_anompb_bt_biharmonic", "description": " For spatially smoothing the anomalous pbot_t field at each barotropic time step using a biharmonic operator. May not be necessary when when pred_corr_gamma > 0.0, since predictor-corrector has dissipation from pred_corr_gamma > 0.0. This option is applicable just for PRESSURE_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. WARNING: This operator is NOT positive definite, and so can produce spurious extrema. It is not recommended just for this reason. Default smooth_anompb_bt_biharmonic=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_pbot_t_laplacian", "description": " For spatially smoothing pbot_t-pbot0 on the big time step using a laplacian operator. For compatibility and global conservation, must also introduce a mixing to the thickness weighted tracer concentration in the k=kbot cell. Applicable just for PRESSURE_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. Default smooth_pbot_t_laplacian=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_pbot_t_biharmonic", "description": " For spatially smoothing pbot_t-pbot0 on the big time step by using a biharmonic operator. For compatibility and global conservation, must also introduce a mixing to the thickness weighted tracer concentration in the k=kbot cell. Applicable just for PRESSURE_BASED vertical coordinates. Also, smoothing is not needed in general for Cgrid MOM, since the gravity wave null mode only appears for the Bgrid. WARNING: This operator is NOT positive definite, and so can produce spurious extrema.  It is not recommended just for this reason. Default smooth_pbot_t_biharmonic=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_pbot_t_biharmonic_legacy", "description": " For using an older version of the smooth_pbot_t_biharmonic scheme.  The smooth_pbot_t_biharmonic_legacy option has a minor bug, but it is maintained in order to allow for backward compatible legacy simulations.  It is not recommended for new simulations. To use it requires also setting smooth_pbot_t_biharmonic=.true. Default smooth_pbot_t_biharmonic_legacy=.false. "}, {"default": ".05", "units": "m/sec", "type_": "real", "name": "vel_micom_lap", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of surface height or anomalous bottom pressure.  Default vel_micom_lap=0.05. "}, {"default": ".2", "units": "m/sec", "type_": "real", "name": "vel_micom_lap_diag", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of diagnosed surface height. Default vel_micom_lap_diag=0.2. "}, {"default": ".01", "units": "m/sec", "type_": "real", "name": "vel_micom_bih", "description": " Velocity scale that is used for computing the MICOM biharmonic mixing coefficient used in the biharmonic smoothing of surface height or anomalous bottom pressure. Default vel_micom_bih=0.01. "}, {"default": ".1", "units": "m/sec", "type_": "real", "name": "vel_micom_bih_diag", "description": " Velocity scale that is used for computing the MICOM biharmonic mixing coefficient used in the biharmonic smoothing of diagnosed surface height. Default vel_micom_bih_diag=0.1. "}, {"default": "1e-12", "units": "metre", "type_": "real", "name": "eta_offset", "description": " Uniform offset for use in determining the filter acting on tracer when smoothing the surface height. Default eta_offset=1e-12. "}, {"default": "1e-12", "units": "Pa", "type_": "real", "name": "pbot_offset", "description": " Uniform offset for use in determining the filter acting on tracer when smoothing the bottom pressure anomaly. Default pbot_offset=1e-12. "}, {"default": ".05", "units": "m/sec", "type_": "real", "name": "udrho_lap_vel_micom", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of udrho. This options will soon be removed from MOM. Default udrho_lap_vel_micom=.05 "}, {"default": ".01", "units": "m/sec", "type_": "real", "name": "udrho_bih_vel_micom", "description": " Velocity scale that is used for computing the MICOM biharmonic mixing coefficient used in the biharmonic smoothing of udrho. This options will soon be removed from MOM. Default udrho_bih_vel_micom=.01 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "udrho_bt_lap", "description": " The vertically integrated horizontal momentum can be noisy on the Bgrid. It is therefore sometimes useful to add a smoothing operator to the barotropic time stepping. Here, we apply the laplacian friction as coded in the friction module using the vertically averaged isotropic viscosity as well as a background, and we do so on each barotropic time step.  It is an expensive option.  It is an option rarely used GFDL. This options will soon be removed from MOM. Default udrho_bt_lap=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "udrho_bt_bih", "description": " The vertically integrated horizontal momentum on the Bgrid can be noisy. It is therefore sometimes useful to add a smoothing operator.  Here, we apply the biharmonic friction as coded in the friction module using the vertically averaged isotropic viscosity as well as a  background. Do so on each barotropic time step, which makes it an expensive option. This option is rarely used GFDL. Default udrho_bt_bih=.false. This options will soon be removed from MOM. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "udrho_lap", "description": " The vertically integrated horizontal momentum on the Bgrid can be noisy. It is therefore sometimes useful to add a smoothing operator.  Here, we apply the laplacian friction as coded in the friction module using the vertically averaged isotropic viscosity as well as a background. Do so just on the baroclinic time step, so the option is less expensive than udrho_bt_lap. This options will soon be removed from MOM. Default udrho_lap=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "udrho_bih", "description": " The vertically integrated horizontal momentum on the Bgrid can be noisy. It is therefore sometimes useful to add a smoothing operator.  Here, we apply the biharmonic friction as coded in the friction module using the vertically averaged isotropic viscosity as well as a background. Do so just on the baroclinic time step, so the option is less expensive than udrho_bt_lap. This options will soon be removed from MOM. Default udrho_bih=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "barotropic_time_stepping_A", "description": " Use the general approach from MOM4.0, in which the eta_t and pbot_t fields are updated with a big time step. This is the recommended approach for most applications that do not employ and open boundary condition. Default barotropic_time_stepping_A=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "barotropic_time_stepping_B", "description": " Use the alternative approach in which we assume the barotropic scheme is a predictor-corrector, which is now the default in MOM.  We use this assumption so that the eta_t and pbot_t fields are updated with a time average. This approach is used for open boundary condition applications. Default barotropic_time_stepping_B=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "initsum_with_bar_mom4p0", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "initsum_with_bar_mom4p1", "description": null}, {"default": "0.2", "units": "dimensionless", "type_": "real", "name": "pred_corr_gamma", "description": " Dimensionless dissipation parameter for the preditor-corrector scheme.  Setting pred_corr_gamma=0.0 reduces the scheme to a forward-backward, but it has been found to be unstable. So pred_corr_gamma > 0.0 is recommended.  Note that pred_corr_gamma > 0.25 may be over-dissipated and so may go unstable. Default pred_corr_gamma=0.2. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "barotropic_halo", "description": " Set barotropic_halo > 1 to use wide halo in the barotropic time step to improve the performance. In barotropic time step, most time is spent on mpp_update_domains. Use wide halo to decrease the number of mpp_update_domain calls and hence improve the performance. The default value is barotropic_halo=1, which is the older approach (non-wide halo).  Users are encouraged to experiment with larger halos, as the model speedup can be tremendous. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_legacy_barotropic_halos", "description": null}, {"default": "0.948", "units": "dimensionless", "type_": "real", "name": "alphat", "description": " Dimensionless self-attraction and loading term.  Used only when tidal_forcing=.true. Default alphat=0.948. "}], "filename": "src/mom5/ocean_core/ocean_barotropic.F90"}, {"namelist": "ocean_bbc_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "bmf_implicit", "description": " For incorporating the bottom momentum drag implicitly in time. Default is bmf_implicit=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "cdbot_law_of_wall", "description": " For determining bottom drag coefficient using a constant roughness length. Will take maximum between cdbot and the computed value using law of wall log-profile.  This option of use when have very very refined vertical resolution (say on order of meters) near the bottom. Terrain following coordinates should use this option since they generally have very refined vertical grid spacing on topography. Default is cdbot_law_of_wall=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "cdbot_roughness_length", "description": " For determining bottom drag coefficient using a map of the roughness length. This approach is more relevant for coarse models than the constant roughness length used in the cdbot_law_of_wall option. Default is cdbot_roughness_length=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "cdbot_wave", "description": " For determining bottom drag coefficient using a map of the roughness length and the surface wind wave field. The modified drag coefficient is calculated following Grant and Mattsen. Likewise this method can be improved using more sophisticated wave models including swell. Default is cdbot_wave=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "cdbot_roughness_uamp", "description": " For determining bottom drag coefficient using a map of the roughness length and tidal velocity amplitude. This approach is more relevant for coarse models than the constant roughness length used in the cdbot_law_of_wall option. cdbot_lo <= cdbot(i,j) <= cdbot_hi. Default is cdbot_roughness_length=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_geothermal_heating", "description": null}, {"default": ".001", "units": null, "type_": "real", "name": "convert_geothermal", "description": null}, {"default": "0.01", "units": "metre", "type_": "real", "name": "law_of_wall_rough_length", "description": " Bottom roughness length.  Default is law_of_wall_rough_length=0.01m, following the default used in the Princeton Ocean Model (POM). This value corresponds to \"Law of Wall\" physics. "}, {"default": "2.5e-3", "units": "dimensionless", "type_": "real", "name": "cdbot", "description": " Dimensionless coefficient for quadratic bottom drag. "}, {"default": ".05", "units": "m/s", "type_": "real", "name": "uresidual", "description": " Residual bottom velocity due to unresolved fluctuations (e.g., waves and tides) that contribute to bottom dissipation.  Should be set to zero when running with explicit representation of tidal forcing and when waves are well resolved. Default is uresidual=.05. "}, {"default": "3.0e-3", "units": null, "type_": "real", "name": "cdbot_hi", "description": null}, {"default": "1.0e-3", "units": null, "type_": "real", "name": "cdbot_lo", "description": null}, {"default": "40.0", "units": null, "type_": "real", "name": "cdbot_gamma", "description": null}, {"default": "10.0", "units": "m/s", "type_": "real", "name": "uvmag_max", "description": " Maximum magnitude of the bottom velocity used to compute the bottom momentum drag.  Default is uvmag_max=10.0. "}, {"default": "1.0", "units": "N/m2", "type_": "real", "name": "bmf_max", "description": " Maximum magnitude of the bottom momentum drag. Default is bmf_max=1.0. "}, {"default": "1100.0", "units": "m", "type_": "real", "name": "cdbot_HH", "description": " H0 in a parameterization of cdbot_roughness_uamp. Default is cdbot_HH=1100.0. "}, {"default": "1.0", "units": "m/s", "type_": "real", "name": "cdbot_UU", "description": " U0 in a parameterization of cdbot_roughness_uamp. Default is cdbot_UU=1.0. "}], "filename": "src/mom5/ocean_core/ocean_bbc.F90"}, {"namelist": "ocean_coriolis_nml", "items": [{"default": ".FALSE.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to add contributions from Coriolis force. "}, {"default": "0.5", "units": null, "type_": "real", "name": "acor", "description": " acor=0.0 means explicit Coriolis force.  0.5 < = acor < 1.0 means semi-implicit, and acor = 1.0 is implicit.  This option is only relevant for the Bgrid, since the C-grid compute Coriolis using 3rd order Adams-Bashforth scheme. For the Bgrid, the semi-implicit method removes dtuv time step constraint associated with inertial oscillations, but it leads to Coriolis force affecting energy balances. If use two-level tendency discretization, then acor=0 is NOT allowed since the model will be linearly unstable with growth rate going as f*(delta time). "}], "filename": "src/mom5/ocean_core/ocean_coriolis.F90"}, {"namelist": "ocean_density_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "eos_linear", "description": " Set to true to use an idealized linear equation of state, which has no pressure dependence, and is a linear function of salinity and temperature. Default eos_linear=.false. "}, {"default": "0.255", "units": null, "type_": "real", "name": "alpha_linear_eos", "description": " Constant \"thermal expansion coefficient\" for linear EOS rho = rho0 - alpha_linear_eos*theta + beta_linear_eos*salinity "}, {"default": "0.0", "units": null, "type_": "real", "name": "beta_linear_eos", "description": " Constant \"saline contraction coefficient\" for linear EOS rho = rho0 - alpha_linear_eos*theta + beta_linear_eos*salinity "}, {"default": ".false.", "units": null, "type_": "logical", "name": "eos_preteos10", "description": " Set to true to use pre-TEOS-10 equation of state, which is a function of potential temperature and practical salinity, or conservative temperature and practical salinity. Default eos_preteos10=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "eos_teos10", "description": " Set to true to use TEOS-10 equation of state, which is a function of conservative temperature and absolute salinity. Default eos_teos10=.false. "}, {"default": "20.0", "units": "psu or g/kg", "type_": "real", "name": "s_test", "description": " Salinity for testing the EOS. "}, {"default": "20.0", "units": "C", "type_": "real", "name": "t_test", "description": " Conservative temperature or potential temperature for testing the EOS. "}, {"default": "1000.0", "units": "dbar", "type_": "real", "name": "p_test", "description": " Sea pressure for testing the EOS. "}, {"default": "35.0", "units": "psu or g/kg", "type_": "real", "name": "sn_test", "description": " Salinity the equation for neutral density. "}, {"default": "20.0", "units": "C", "type_": "real", "name": "tn_test", "description": " Conservative temperature or potential temperature for testing the equation for neutral density. "}, {"default": "80", "units": null, "type_": "integer", "name": "layer_nk", "description": " Number of classes used to partition vertical according to potential density, conservative temperature, or potential temperature. Used for diagnostics. "}, {"default": "2000.0", "units": "dbar", "type_": "real", "name": "potrho_press", "description": " Reference sea pressure for computing diagnostic potential density of use for computing diagnostics with potential density. Default potrho_press=2000.0 "}, {"default": "1028.0", "units": "kg/m^3", "type_": "real", "name": "potrho_min", "description": " Minimum potential density used to partition vertical according to potential density. "}, {"default": "1038.0", "units": "kg/m^3", "type_": "real", "name": "potrho_max", "description": " Maximum potential density used to partition vertical according to potential density. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_density_omega", "description": " Set to true to compute the neutral density according to the omega method based on Klocker and McDougall. This approach has not yet been coded. Presently as a placeholder we use potential density referenced to 2000dbar. Default neutral_density_omega=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_density_potrho", "description": " Set to true to compute the neutral density as just a selected potential density, set according to potrho_press. Since the neutral_density_omega approach has yet to be coded, we only have the neutral_density_potrho option to choose from at this time. Default neutral_density_potrho=.true. "}, {"default": "1020.0", "units": "kg/m^3", "type_": "real", "name": "neutralrho_min", "description": " Minimum neutral density used to partition vertical according to rational polynomial approximation to neutral density. "}, {"default": "1030.0", "units": "kg/m^3", "type_": "real", "name": "neutralrho_max", "description": " Maximum neutral density used to partition vertical according to rational polynomial approximation to neutral density. "}, {"default": "-2.0", "units": "C", "type_": "real", "name": "theta_min", "description": " Minimum conservative temperature or potential temperature used to partition vertical according to temperature. "}, {"default": "30.0", "units": "C", "type_": "real", "name": "theta_max", "description": " Maximum conservative temperature or potential temperature used to partition vertical according to temperature. "}, {"default": "0.0", "units": "dbar", "type_": "real", "name": "press_standard", "description": " Standard atmospheric pressure (dbar).  The realistic EOS used in MOM requires \"sea pressure\" as an argument rather than absolute pressure.  Sea pressure is absolute pressure minus a standard atmospheric pressure of 10.1325dbar.  For models that do have a realistic atmospheric loading, then it is appropriate to remove 10.1325dbar prior to computing the EOS. For those cases with zero atmospheric pressure, then it is not necessary to remove the standard atmosphere.  The default for the press_standard is 0.0dbar. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "buoyfreq_smooth_vert", "description": " To smooth the vertical temp and salt derivative for diagnosing the buoyancy frequency. Default buoyfreq_smooth_vert=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": null}, {"default": "1.e-10", "units": "kg/m4", "type_": "real", "name": "epsln_drhodz", "description": " To normalize the inverse vertical derivative of neutral density for computing the buoyancy frequency. Default epsln_drhodz=1e-10. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "drhodz_diag_stable", "description": " When computing drhodz_diag, we can enforce that it is negative, thus reflecting a stable stratification.  The field drhodz_diag is used for many water mass transformation diagnostics, such as wdian_rho.  Allowing for unstable profiles can bias the wdian_rho calculation in an improper way, since the magnitude of drhodz_diag is very small when it is positive, whereas it is larger magnitude when negative.  Default drhodz_diag_stable=.true. "}, {"default": "1.e-10", "units": "kg/m4", "type_": "real", "name": "epsln_drhodz_diag", "description": " To normalize the inverse vertical derivative of neutral density for computing neutral_rho and wdian diagnostics. Default epsln_drhodz_diag=1e-10. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "grad_nrho_lrpotrho_compute", "description": " To perform the diagnostic calculation of grad_nrho_lrpotrho for analysis diagnostics.  This factor is not well constrained, and can be problematic in certain regions.  So presently we do not recommend computing it, so that the default is grad_nrho_lrpotrho_compute=.false. "}, {"default": "10.0", "units": "dimensionless", "type_": "real", "name": "grad_nrho_lrpotrho_max", "description": " Maximum value used for grad_nrho_lrpotrho. Default grad_nrho_lrpotrho_max=10. "}, {"default": "1.0", "units": "dimensionless", "type_": "real", "name": "grad_nrho_lrpotrho_min", "description": " Minimum value used for grad_nrho_lrpotrho. Default grad_nrho_lrpotrho_min=1. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_stratification_factor", "description": " For doing an S2D smoothing of the stratification factor used for diagnostic purposes.  Requires an extra call to mpp update. Default smooth_stratification_factor=.false. since the smoothing incurs a cost that should be borne only when desired. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smax_min_in_column", "description": " To compute the diagnostic maximum neutral slope within a column as the minimum vertical to horizontal grid aspect ratio.  This method ensures that the slope is adequately \"resolved\" by the grid, and that all depths use the same definition of \"resolved\", even if presumably thicker grid cells can \"resolve\" larger neutral slopes.  This approach is not very useful generally, so it is retained only for testing purposes. Default smax_min_in_column=.false. "}, {"default": "-1.0", "units": "dimensionless", "type_": "real", "name": "smax_diag", "description": " A diagnostic maximum neutral slope for use in computing which direction is deemed the most stratified.  For use in computing the stratification_factor which is then used to diagnose the dianeutral mass transport. smax_diag should corresond to the choice used in neutral diffusion scheme. Should have 0 <= smax_diag <= 1.0. Default smax_diag=-1.0, in which case we compute the smax according to the vertical to horizontal grid aspect ratio.  This method ensures that the slope is adequately \"resolved\" by the grid. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "update_diagnostic_factors", "description": " To update the watermass_factor and stratification_factor for use in the water mass transformation diagnostics. Default update_diagnostic_factors=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "mask_domain_restart", "description": " For cases where use the domain masking, it is necessary to initialize the field denominator_r to nonzero in order to avoid NaNs in the case when change processor layout in between restarts.  Note that when use solid wall boundary conditions, this logical should remain false in order to bitwise reproduce across restarts. Default mask_domain_restart=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging nonlinear equation of state "}, {"default": ".false.", "units": null, "type_": "logical", "name": "rho0_density", "description": " For debugging, it is often useful to have rho=rho0 uniform. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "density_equal_potrho", "description": " For idealized tests, set the in situ density equal to the potential density referenced to potrho_press.  All density derivatives will also be computed with respect to constant potrho_press pressure. Default density_equal_potrho=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. default: do_bitwise_exact_sum=.false. "}], "filename": "src/mom5/ocean_core/ocean_density.F90"}, {"namelist": "ocean_domains_nml", "items": [{"default": "1", "units": "dimensionless", "type_": "integer", "name": "halo", "description": " For specifying the halo size by hand. "}, {"default": "10", "units": "dimensionless", "type_": "integer", "name": "max_tracers", "description": " temporary - need to call domains_init before tracer_init Used for computing mpp_stack_size. "}, {"default": "0", "units": "dimensionless", "type_": "integer", "name": "x_cyclic_offset", "description": " offset to be applied on x-direction boundary condition. Its value could be positive or negative and the default value is 0. When the y-direction boundary condition is folded-north(tripolar grid), x_cyclic_offset must be 0. For torus (cyclic in x and y-direction), at least one of x_cyclic_offset and y_cyclic_offset must be 0. "}, {"default": "0", "units": "dimensionless", "type_": "integer", "name": "y_cyclic_offset", "description": " offset to be applied on y-direction boundary condition. Its value could be positive or negative and the default value is 0. For torus (cyclic in x and y-direction), at least one of x_cyclic_offset and y_cyclic_offset must be 0. "}], "filename": "src/mom5/ocean_core/ocean_domains.F90"}, {"namelist": "ocean_grids_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is do_bitwise_exact_sum=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. Note that most of the debugging stuff has been removed, but keep flag around in case need in future. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " Prints out lots of initial checksums.  Useful to have on, so defaulted to true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_rho0_profile", "description": " To read in an initial rho0(k) profile to assist in defining the initial settings for the pressure increments dst, for use in setting the pressure-based vertical coordinate grids.  Ideally, this profile is determined by the level averaged density in the initial conditions. Note that it is essential to have rho0_profile have a sensible value at all depths even if there is no water there, since there are places where we divide by rho0_profile in rock.  Also, be mindful that with denser water at depth, the pressure levels will be coarser at depth than if using the trivial density profile rho0(k)=rho0. This option is experimental, so it is recommended that user maintain the default read_rho0_profile=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "write_grid", "description": null}], "filename": "src/mom5/ocean_core/ocean_grids.F90"}, {"namelist": "ocean_model_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "impose_init_from_restart", "description": " Consider the following situation:  We have run the model for many years and generated restarts. Time%init is then .false.  Then, we wish to start a series of perturbation experiments from this restart file.  The generic situation is for Time%init to then be .true. However, we need it to be .false. in MOM in order to have a proper reading of the full restart information. Setting impose_init_from_restart=.true. will facilitate this setup.  The default is impose_init_from_restart=.false., in which case the model will run through its normal start/stop segments using restarts. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "reinitialize_thickness", "description": " When initialized with a nontrivial eta field, it is necessary to reinitialize the thickness arrays. "}, {"default": "1", "units": null, "type_": "integer", "name": "baroclinic_split", "description": " baroclinic_split = dtts/dtuv = (tracer time step)/(baroclinic time step) = (ocean model time step)/(baroclinic time step) Transients corrupted if baroclinic_split > 1, so it is recommended to use baroclinic_split=1. "}, {"default": "1", "units": null, "type_": "integer", "name": "surface_height_split", "description": " Ratio surface_height_split = dtts/dteta = (tracer time step)/(surface height time step) = (tracer time step)/(bottom pressure time step) Typically this split is set to unity for models where baroclinic_split=1, but something larger when baroclinic_split is order 10.  dteta is the time step used for update of eta_t or pbot_t. If surface_height_split is not equal to unity, then tracer conservation properties are compromised. "}, {"default": "30", "units": null, "type_": "integer", "name": "barotropic_split", "description": " Ratio barotropic_split = dtuv/dtbt = (baroclinic time step)/(barotropic time step). Must be large enough to resolve the barotropic gravity waves captured by the barotropic part of the model. Barotropic waves are dissipated when this splitting is greater than unity. Model algorithm is not fully implemented when barotropic_split=1, so user beware if wishing to run an unsplit model simulation. "}, {"default": "'twolevel'", "units": null, "type_": "character(len=32)", "name": "time_tendency", "description": "  Possible time stepping schemes are the following.  1. \"threelevel\" has the following characteristics  leap-frog for the time tendency which means the inviscid/nondissipative processes are at time tau.  forward for lateral mixing processes (dissipation at taum1)  implicit for vertical dissipative (with aidif = 1.0)  semi-implicit for Coriolis (with acor>0)  Because of the need to apply time filters to suppress leap-frog splitting, the threelevel time stepping scheme does not conserve total tracer content in the model.  2. \"twolevel\" has the following characteristics:  staggered 2nd order forward time tendency, which means that tracer advection, lateral tracer and velocity mixing, are at time tau. Pressure gradients are at taup1.  Adams-Bashforth (either 2nd or 3rd order) for velocity advection Third order is default as it is more stable.  implicit vertical mixing (with aidif = 1.0)  semi-implicit for Coriolis (with acor > 0)  This scheme conserves total volume and tracer in the ocean model.  "}, {"default": "'zstar'", "units": null, "type_": "character(len=32)", "name": "vertical_coordinate", "description": " This string determines the vertical coordinate used in MOM.  There are 3 + 3 options in MOM: Depth-based Boussinesq are 'geopotential', 'zstar', 'zsigma', Pressure-based non-Boussinesq are 'pressure', 'pstar', and 'psigma'.  The two terrain-following sigma options are not well tested in MOM, whereas the other options are standard.  The recommended Boussinesq vertical coordinate is zstar, and the recommended non-Boussineq coordinate is pstar.  The default is vertical_coordinate='zstar'. "}, {"default": "'bgrid'", "units": null, "type_": "character(len=32)", "name": "horizontal_grid", "description": " This string determines the arrangement of variables on the discrete horizontal grid. The standard case is horizontal_grid='bgrid'. However, the C-grid is being developed in MOM.  It is not yet supported for general use. Default horizontal_grid='bgrid'. "}, {"default": "(/1,1/)", "units": null, "type_": "integer(2)", "name": "layout", "description": " Processor domain layout for ocean model. "}, {"default": "(/0,0/)", "units": null, "type_": "integer(2)", "name": "io_layout", "description": " Processor IO domain layout for ocean model. The default value is (0,0). If either io_layout(1) or (2) is 0, it will default to the number of processors in the computational layout, except restart file will default to single file if fms_io_nml fileset_write is set to 'single'.  When both entry of io_layout is positive, io_domain will be defined(a pointer in domain2d) and number of distributed files will be layout(1)*layout(2). For example, assume the restart file is ocean_velocity.res.nc and the diagnostics file is ocean_daily.nc, if the layout = (1,2), the restart files will be ocean_velocity.res.nc.0000 and ocean_veloicity.res.nc.0001, the diagnostics files will be ocean_daily.res.nc.0000 and ocean_daily.res.nc.0001. When the io_domain is defined, restart file and diagnostics file name will be controlled by the io_domain (ignoring fms_io_nml fileset_write). "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug", "description": " For overall model debugging. Set true to print cksums at each timestep for debugging purposes. "}, {"default": "\"INPUT/ocean_mask_table\"", "units": null, "type_": "character(len=128)", "name": "mask_table", "description": " A text file to specify n_mask, layout and mask_list.  This table aims to reduce the number of processors that are cycling over pure land regions.  These processors will be masked out of regions that which contain all land points.  The default file name of mask_table is \"INPUT/ocean_mask_table\". Please note that the file name must begin with \"INPUT/\".  The first line of mask_table is the number of region to be masked out. The second line is the layout of the model. User need to set ocean_model_nml variable layout to be the same as the second line of the mask table. The following n_mask line will be the position of the processor to be masked out.  The mask_table could be created by tools check_mask.  For example the mask_table will be as following if n_mask=2, layout=4,6 and the processor (1,2) and (3,6) are to be masked out. 2 4,6 1,2 3,6 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "cmip_units", "description": " For CMIP output, we need to have temperature in deg K and mass transport in kg/s.  The flag cmip_units=.true. will diagnose CMIP5-related fields with the CMIP units for sending to the diagnostic manager. Default cmip_units=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_blobs", "description": " For using Lagrangian blobs. Default use_blobs=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "introduce_blobs", "description": " For the Lagrangian blobs after a model has already been running. Default introduce_blobs=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_velocity_override", "description": " For over-riding the velocity field with values from a file.  Note that we need separate files for (u,v) read into ocean_velocity.F90, as well as (udrho,vdrho) read into ocean_barotropic.F90. Default use_velocity_override=.false. "}, {"default": "-1", "units": null, "type_": "integer", "name": "dt_ocean", "description": " Ocean model time step in seconds. "}], "filename": "src/mom5/ocean_core/ocean_model.F90"}, {"namelist": "ocean_obc_nml", "items": [{"default": null, "units": null, "type_": "integer", "name": "direction", "description": " open boundary direction. Each element value should be west, east, south or north. "}, {"default": null, "units": null, "type_": "character(len=16)", "name": "name", "description": " type of open bounday. "}, {"default": null, "units": null, "type_": "real", "name": "ctrop_max", "description": " Maximum value to clip diagnosed barotropic phase speed in terms of sqrt(gH). Should be about  1. "}, {"default": null, "units": null, "type_": "real", "name": "ctrop_min", "description": " Minimum value to diagnosed barotropic phase speed in terms of sqrt(gH). Should be about  0.  Default is 0.1. "}, {"default": null, "units": null, "type_": "real", "name": "ctrop_inc", "description": " value to be set for barotropic phase speed if incoming waves are diagnosed. (in terms of sqrt(gH)) Should be about 0. Default is 0. "}, {"default": null, "units": null, "type_": "real", "name": "ctrop_smooth", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "enh_pnts", "description": " Enhance viscosity and mixing at a stripe of enh_pnts decreasing with the distance from the boundary. Default = 1. "}, {"default": null, "units": null, "type_": "real", "name": "enh_fac_v", "description": " 'Safety factor' applied to maximum stable viscosity at the boundary. Default = 0.9 "}, {"default": null, "units": null, "type_": "real", "name": "enh_fac_d", "description": " Factor applied to enhance mixing at the boundary. Default = 1. "}, {"default": null, "units": null, "type_": "integer", "name": "obc_enhance_visc_back", "description": " logical variable that decide whether to enhance viscosity at the boundary. Default value is .false. "}, {"default": null, "units": null, "type_": "integer", "name": "obc_enhance_diff_back", "description": " logical variable that decide whether to enhance mixing at the boundary. Default value is .false. "}, {"default": null, "units": null, "type_": "logical", "name": "obc_consider_convu", "description": " logical variable that decide whether to account for one component of convu within the boundary. The appropriate behavior depends on the model configuration. Default value is .false. "}, {"default": null, "units": null, "type_": "logical", "name": "obc_vert_advel_t", "description": " logical variable that decide whether to account for vertical advection of tracers at the boundary. The appropriate behavior depends on the model configuration. Default value is .false. (Currently inactive) "}, {"default": null, "units": null, "type_": "logical", "name": "obc_vert_advel_u", "description": " logical variable that decide whether to account for vertical advection of momentum at the boundary. The appropriate behavior depends on the model configuration. Default value is .false. "}, {"default": null, "units": null, "type_": "logical", "name": "obc_adjust_forcing_bt", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "obc_damp_newton", "description": null}, {"default": null, "units": null, "type_": "real", "name": "damp_factor", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "nobc", "description": " number of open boundary condition. Its value should be less than max_obc. Increase max_obc if needed. "}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "is", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "ie", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "js", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "je", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "iers", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "iere", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "jers", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "jere", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "itrs", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "itre", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "jtrs", "description": null}, {"default": "-999", "units": null, "type_": "integer(max_obc)", "name": "jtre", "description": null}, {"default": "'NOGRAD'", "units": null, "type_": "character(len=128)(max_obc)", "name": "obc_nor", "description": " Normal velocity OBC "}, {"default": "'NOGRAD'", "units": null, "type_": "character(len=128)(max_obc)", "name": "obc_tan", "description": " Tangential velocity OBC "}, {"default": "'NOTHIN'", "units": null, "type_": "character(len=128)(max_obc)", "name": "obc_eta", "description": " Surface elevation OBC "}, {"default": "'NOGRAD'", "units": null, "type_": "character(len=128)(max_obc)", "name": "obc_ud", "description": null}, {"default": "'NOGRAD'", "units": null, "type_": "character(len=128)(max_obc)", "name": "obc_mix", "description": " Vertical mixing coefficient OBC "}, {"default": "'NOGRAD'", "units": null, "type_": "character(len=128)(max_obc,max_prog_tracers)", "name": "obc_tra", "description": " Tracers OBC "}, {"default": "0.0", "units": null, "type_": "real(max_obc)", "name": "rel_coef_eta_in", "description": " Relaxation coefficient to be used for incoming wave situation. "}, {"default": "0.0", "units": null, "type_": "real(max_obc)", "name": "rel_coef_eta_out", "description": " Relaxation coefficient to be used for outgoing wave situation. Should be smaller then or equal to rel_coef_eta_in. "}, {"default": "1", "units": null, "type_": "integer(max_obc)", "name": "rel_eta_pnts", "description": " Relax sea level at a stripe of rel_eta_pnts. Default = 1. "}, {"default": null, "units": null, "type_": "character(len=256)(max_obc)", "name": "filename_eta", "description": " Filename to read sea level data. "}, {"default": null, "units": null, "type_": "character(len=32),  dimension(max_obc)", "name": "fieldname_eta", "description": " Fieldname  to read sea level data. "}, {"default": null, "units": null, "type_": "character(len=256)(max_obc)", "name": "filename_ud", "description": null}, {"default": null, "units": null, "type_": "character(len=32),  dimension(max_obc)", "name": "fieldname_ud", "description": null}, {"default": ".FALSE.", "units": null, "type_": "logical(max_obc,max_prog_tracers)", "name": "obc_relax_tracer", "description": " logical variable that decide whether relax tracer or not. Default value is .false. "}, {"default": "1", "units": null, "type_": "integer(max_obc,max_prog_tracers)", "name": "obc_flow_relax", "description": " Integer variable specifying the flow relaxation zone (flow realxation of Martinsen and Engedahl (1987). Default value is 1. "}, {"default": ".FALSE.", "units": null, "type_": "logical(max_obc,max_prog_tracers)", "name": "obc_consider_sources", "description": " Logical variable specifying if source and SGS terms of the normal tracer scheme are valid. Default value is .false.. "}, {"default": ".FALSE.", "units": null, "type_": "logical(max_obc,max_prog_tracers)", "name": "obc_tracer_no_inflow", "description": " logical variable that decide whether apply orlanski obc on tracer or not. Default value is .false. "}, {"default": "1", "units": null, "type_": "integer(max_obc,max_prog_tracers)", "name": "rel_clin_pnts", "description": " Relax a tracer at a stripe of rel_clin_pnts. Default = 1. "}, {"default": "0.0", "units": null, "type_": "real(max_obc,max_prog_tracers)", "name": "rel_coef_tracer_in", "description": " Relaxation coefficient to be used for inflow situation. "}, {"default": "0.0", "units": null, "type_": "real(max_obc,max_prog_tracers)", "name": "rel_coef_tracer_out", "description": " Relaxation coefficient to be used for outflow situation. Should be smaller then or equal to rel_coef_tracer_in. "}, {"default": null, "units": null, "type_": "character(len=32),  dimension(max_obc,max_prog_tracers)", "name": "fieldname_tracer", "description": " Fieldname of a tracer. "}, {"default": null, "units": null, "type_": "character(len=256)(max_obc,max_prog_tracers)", "name": "filename_tracer", "description": " Filename to read a tracer. It is allowed to put all data for a boundary in one file. "}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "debug_phase_speed", "description": " Includes the phase speed into the model output. "}], "filename": "src/mom5/ocean_core/ocean_obc.F90"}, {"namelist": "ocean_operators_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_legacy_DIV_UD", "description": " Set use_legacy_DIV_UD=.true. to reproduce Riga results for DIV_UD on Bgrid. For the case that the model grid is tripolar grid, when barotropic_halo > 1 in ocean_barotropic.F90, then we must set use_legacy_DIV_UD=.false., since will not reproduce between different number of processors if set use_legacy_DIV_UD=.true.  Tests indicate that with wider barotropic halos, there are some performance enhancements for use_legacy_DIV_UD=.false. Hence, the default is use_legacy_DIV_UD=.false.  For the case that the model grid is regular lat-lon grid, use_legacy_DIV_UD could be set to .true. or .false. for any positive value of barotropic_halo.  Note that the only difference between the new and old DIV_UD is order of operations induced by parentheses, which occurs in the tripolar fold region in the Arctic: old: DIV_UD(i,j) = (uh_bay  - uhim_bay  + vh_bax  - vhjm_bax)*datr_bt(i,j) new: DIV_UD(i,j) = ((uh_bay - uhim_bay) + (vh_bax - vhjm_bax))*datr_bt(i,j) "}], "filename": "src/mom5/ocean_core/ocean_operators.F90"}, {"namelist": "ocean_parameters_nml", "items": [{"default": "9.80", "units": "m/s^2", "type_": "real", "name": "grav", "description": " Gravitational acceleration at earth surface. Assumed to be constant throughout the ocean domain.  Default grav=9.8 corresponds to the \"grav\" parameter from shared/constants.F90. "}, {"default": "3992.10322329649", "units": "J/(kg degC)", "type_": "real", "name": "cp_ocean", "description": " Specific heat capacity J/(kg degC) for liquid seawater. Values are taken from from Jackett etal (2006) for preTEOS10 and from TEOS-10 manual for TEOS10 value. The default values differ from that in shared/constants since the MOM defaults are more updated. Note that there is a check inside of ocean_tempsalt.F90 to ensure that cp_ocean=cp_ocean_teos10 if using the teos10 recommendations, and cp_ocean=cp_ocean_preteos10 for cases not using teos10. "}, {"default": "2106.", "units": "J/(kg degC)", "type_": "real", "name": "cp_solid_runoff", "description": " Specific heat capacity J/(kg degC) for solid water runoff via calving land ice. Default cp_solid_runoff = 2106.0 is consistent with that used in the GFDL land model. "}, {"default": "4218.", "units": "J/(kg degC)", "type_": "real", "name": "cp_liquid_runoff", "description": " Specific heat capacity J/(kg degC) for liquid water runoff from land. Default cp_liquid_runoff = 4218.0 is consistent with that used in the GFDL land model. "}, {"default": "1035.0", "units": "kg/m^3", "type_": "real", "name": "rho0", "description": " Boussinesq reference density.  Default rho0=1035.0 corresponds to the value in Gill (page 47), where he notes that the ocean density typically deviates less than 2 per cent from this value. But if using the Boussinesq approximation for other water bodies, such as the Baltic, then may wish to change rho0 to a more appropriate value. "}, {"default": "273.15", "units": "Kelvin", "type_": "real", "name": "tfreeze", "description": " freezing point of fresh water at standard atmos pressure. Default tfreeze=273.15 "}, {"default": "7.2921e-5", "units": "radians per second", "type_": "real", "name": "omega_earth", "description": " rotation of earth in radians per second Default omega_earth= 7.2921e-5, as per equation (4.1) in Griffies (2004). "}], "filename": "src/mom5/ocean_core/ocean_parameters.F90"}, {"namelist": "ocean_pressure_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_pressure_force", "description": " For debugging it is often useful to zero the pressure force to zero. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_correction_term_grad", "description": " For debugging it is often useful to zero the contribution to the pressure gradient that arises from the \"correction\" term. Implemented only for depth based vertical coordinate models. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_diagonal_press_grad", "description": " For debugging it is often useful to zero the contribution to the pressure gradient that arises from the along k-level gradient. Implemented only for depth based vertical coordinate models. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_eta_over_h_zstar_pressure", "description": " For debugging zstar, we drop any eta/H contribution to the hydrostatic pressure.  This is wrong physically, but useful for certain tests. "}], "filename": "src/mom5/ocean_core/ocean_pressure.F90"}, {"namelist": "ocean_sbc_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "use_waterflux", "description": " Set to true when wish to use real fresh water flux as opposed to virtual salt fluxes. This is the recommended method. The alternative virtual tracer flux method (use_waterflux=.false.) is not routinely used at GFDL, so it may suffer from poor testing. Default use_waterflux=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "waterflux_tavg", "description": " Set to true when aiming to suppress the leap-frog computational mode by setting pme and river equal to a time averaged value over the present and previous time step.  This method requires an extra field in the restart file.  This method is not needed when using the TWO_LEVEL time tendency.  It remains for those who wish to use the leap-frog THREE_LEVEL time stepping scheme. Note that it does not lead to simple checks of conservation across model components, since there is a time averaging performed for the water flux added to the ocean model.  It is generally NOT recommended.  Default waterflux_tavg=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_waterflux_override_calving", "description": " Set to true will allow for model to incorporate the latent heating from a calving field that comes in through coupled model instantaneous interactions, but later will over-ride the mass flux from calving with a dataset that is read in from a climatology or observations. The idea is to only modify the mass contribution from calving through the over-ride, and leave the latent heat contribution untouched. Default use_waterflux_override_calving=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_waterflux_override_fprec", "description": " Set to true will allow for model to incorporate the latent heating from a fprec field that comes in through coupled model instantaneous interactions, but later will over-ride the mass flux from fprec with a dataset that is read in from a climatology or observations. The idea is to only modify the mass contribution from fprec through the over-ride, and leave the latent heat contribution untouched. Default use_waterflux_override_fprec=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_waterflux_override_evap", "description": " Set to true will allow for model to incorporate the latent heating from an evap field that comes in through coupled model instantaneous interactions, but later will over-ride the mass flux from evap with a dataset that is read in from a climatology or observations. The idea is to only modify the mass contribution from evap through the over-ride, and leave the latent heat contribution untouched. Default use_waterflux_override_evap=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "rotate_winds", "description": " Set to true when need to rotate the winds onto the ocean model grid. This is needed for cases where the winds are on a spherical grid and the ocean model uses tripolar=.true.  If generate the wind data on the ocean model grid, then do not need to rotate, since the rotation has already been done. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "runoffspread", "description": " Set to true if wish to use the spread_river_horz algorithm to spread the river runoff flux horizontally over an area into the ocean wider than set by the coupler.  This option requires the setup of a table for determining the points over which we spread. Default runoffspread=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "calvingspread", "description": " Set to true if wish to use the spread_river_horz algorithm to spread the calving flux horizontally over an area into the ocean wider than set by the coupler.  This option requires the setup of a table for determining the points over which we spread. Default calvingspread=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "salt_restore_under_ice", "description": " Logical indicating whether to restore salinity under sea ice or not. When .false. then will not restore salinity  in regions where we use a \"frazil\" condition as a proxy for where sea-ice is present. Do not use sea ice extent from a sea ice model since we generally do not pass information regarding ice extent between the sea ice model and the ocean model. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "salt_restore_as_salt_flux", "description": " When running a use_waterflux=.true. model, we may choose to add the salinity from a restoring condition as a salt flux or convert to a fresh water flux. The addition of salt does not alter the sea level nor does it alter the concentration of other tracers, whereas converting to an implied water flux will alter sea level and other concentrations.  So we generally recommend the default salt_restore_as_salt_flux=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_salt_restore", "description": " Logical indicating whether to remove the area mean of the salinity restore flux so there is a net zero input of salt to the ocean associated with restoring. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_salt_correction", "description": " Logical indicating whether to remove the area mean of the salinity correction flux so there is a net zero input of salt to the ocean associated with salt correction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_water_restore", "description": " Logical indicating whether to remove the area mean of the water restore flux so there is a net zero input of water to the ocean associated with restoring. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_water_correction", "description": " Logical indicating whether to remove the area mean of the water correction flux so there is a net zero input of water to the ocean associated with water correction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_water_coupler", "description": " Logical indicating whether to remove the area mean of the water passed through the coupler so there is a net zero input of fresh water to the ocean associated with p-e+r. Do so by removing area mean from pme--keep river values unchanged. Note that a choice must be made whether to remove the area mean from rivers or pme. We choose pme since it is more evenly distributed than rivers. Also note that we DO NOT include the ice melt in this normalization. The reason is that we only wish to ensure the ocean+ice system has a zero net water.  When melt or form sea ice, this only transfers water between liquid ocean and solid sea ice, and no normalization is appropriate for this case. It is only the water exchanged with the land and atmosphere that is normalized. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_water_couple_restore", "description": " This logical keeps the total water forcing on the ocean+ice system to a global mean of zero at each time step.  We DO NOT include the ice melt in this normalization. Setting zero_net_water_couple_restore to true may be appropriate when running an ice-ocean model using a bulk formulae to compute evaporation (e.g., CORE) and when only providing a weak (or zero) salinity restoring.  It is not appropriate when running a coupled ocean-atmosphere model, where the moisture budget should be conserved without an artificial removal of the global mean. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_net_pme_eta_restore", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_water_fluxes", "description": " Logical for debugging water fluxes. Must be true for any of the options zero_water_fluxes, zero_calving_fluxes, zero_pme_fluxes or zero_runoff_fluxes to be enabled. Default debug_water_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_water_fluxes", "description": " Logical for debugging to zero the pme, river, and pme_taum1 into ocean, over-riding any input from Ice_ocean_boundary. Default zero_water_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_pme_fluxes", "description": " Logical for debugging to zero the pme flux passed into the ocean. Default zero_pme_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_calving_fluxes", "description": " Logical for debugging to zero the calving flux passed into the ocean. Default zero_calving_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_runoff_fluxes", "description": " Logical for debugging to zero the runoff flux passed into the ocean. Default zero_runoff_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_river_fluxes", "description": " Logical for debugging to zero the river (calving+runoff) flux passed into the ocean. Default zero_river_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "convert_river_to_pme", "description": " Logical for debugging.  Here we add the river water input (calving+runoff) to pme, then set river=calving=runoff=0.0. Default convert_river_to_pme=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_heat_fluxes", "description": " Logical for debugging to set all heat fluxes into the ocean to zero, over-riding any input from Ice_ocean_boundary.  Default is .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_surface_stress", "description": " Logical for debugging to zero all surface stress applied to the ocean, over-riding any input from Ice_ocean_boundary.  Default is .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_restore_mask", "description": " For reading in a mask that selects regions of the domain that are restored (mask=1) or not restored (mask=0). Default  read_restore_mask=.false., whereby restore_mask is set to tmask(k=1). "}, {"default": ".false.", "units": null, "type_": "logical", "name": "restore_mask_gfdl", "description": " For modifying the restore mask based on reading in the GFDL regional mask. Default restore_mask_gfdl=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "land_model_heat_fluxes", "description": " For the case where land model passes through the coupler the heat flux associated with the liquid runoff and calving land ice fields. This heat flux is computed relative to 0C, and takes the form heat flux = mass flux of water * temp of water * heat capacity, where the water can be either liquid or solid.  For many coupled models, the water temperature is assumed to be that of the SST.  But more complete land models now carry the heat of its water relative to 0C, in which case the ocean model does not need to assume anything about the heat content of the land water. Default land_model_heat_fluxes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_flux_correction", "description": " For applying surface flux correction to to a tracer or wind stress field. This code is used at GFDL for idealized perturbation experiments, such as when one wishes to artificially enhance the wind stress to test model sensitivity.  It is also appropriate for coupled models that may require a modification to the fluxes arrising from a coupled model, via reading in information from a pre-defined data file, Default do_flux_correction=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sbc_heat_fluxes_const", "description": " Logical for setting the surface heat flux from the coupler to a global constant. Default is sbc_heat_fluxes_const=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sbc_heat_fluxes_const_seasonal", "description": " Logical for setting the surface heat flux from the coupler to a global constant, and giving it a seasonally varying amplitude. Default is sbc_heat_fluxes_const_seasonal=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_constant_sss_for_restore", "description": " To over-ride the sfc_restore.nc value for salinity restoring. use_constant_sss_for_restore=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_constant_sst_for_restore", "description": " To over-ride the sfc_restore.nc value for temp restoring. use_constant_sst_for_restore=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_ideal_runoff", "description": " To add an idealized liquid runoff read from a file. This runoff is assumed to enter the ocean with the same temperature as SST, and to be liquid.  It is an additional runoff, so that any other runoff remains unaltered.  The runoff coming from idealized runoff is NOT subject to the global normalization realized from zero_net_water_coupler=.true. Default use_ideal_runoff=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_ideal_calving", "description": " To add an idealized solid runoff or calving read from a file. This calving runoff is assumed to require melting, so it extracts latent heat of fusion from the liquid ocean The runoff coming from idealized cavling is NOT subject to the global normalization realized from zero_net_water_coupler=.true. Default use_ideal_calving=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_stokes_drift", "description": " This option is to be used when coupling to a surface wave model such as Wavewatch III that provides both the Stokes drift (m/s) velocity at the ocean surface, and a decay scale for projecting the Stokes drift into the interior.  Default read_stokes_drift = .false. "}, {"default": "35.0", "units": "psu", "type_": "real", "name": "constant_sss_for_restore", "description": " The SSS value used if use_constant_sss_for_restore=.true. Default constant_sss_for_restore=35.0 "}, {"default": "12.0", "units": "degC", "type_": "real", "name": "constant_sst_for_restore", "description": " The SST value used if use_constant_sst_for_restore=.true. Default constant_sst_for_restore=12.0 "}, {"default": "0.0", "units": "W/m2", "type_": "real", "name": "sbc_heat_fluxes_const_value", "description": " Value for the constant heat flux when using sbc_heat_fluxes_const=.true. Default sbc_heat_fluxes_const_value=0.0. "}, {"default": "0.005", "units": "kg salt / kg ice", "type_": "real", "name": "ice_salt_concentration", "description": " The salt concentration of sea ice.  This is taken as a bulk value, and should be the same as that used by the ice model. Default is ice_salt_concentration=0.005, as that is the value used in the GFDL coupled climate model. "}, {"default": "0.0", "units": "g salt / kg runoff water (ppt)", "type_": "real", "name": "runoff_salinity", "description": " The salinity of river runoff water. Default is runoff_salinity=0.0. "}, {"default": "0.0", "units": "DegC", "type_": "real", "name": "runoff_temp_min", "description": " The minimum temperature that river runoff into the ocean is assigned. Default runoff_temp_min=0.0. "}, {"default": "-30.", "units": "day", "type_": "real", "name": "temp_restore_tscale", "description": " Time scale in days for restoring temperature within the top model grid cell. "}, {"default": "-30.", "units": "day", "type_": "real", "name": "salt_restore_tscale", "description": " Time scale in days for restoring salinity within the top model grid cell. "}, {"default": "-30.", "units": "day", "type_": "real", "name": "eta_restore_tscale", "description": " Time scale in days for restoring surface height to produce a modification to surface water flux.  This option is only available when run with use_waterflux=.true. "}, {"default": "5.0", "units": "m", "type_": "real", "name": "max_ice_thickness", "description": " When coupling MOM to an ice model, the sea ice thickness may need to be restricted to prevent vanishing top-level in MOM. Set max_ice_thickness (meters) < dzt(k=1) to restrict. This truncation avoids the numerical problem but we loose mass conservation in the coupled sea ice and ocean system. We also alter the pressure felt on the ocean as applied by the sea ice. Different vertical coordinates are needed to do the problem more realistically.  Note that the problem of vanishing top layer is removed when use either ZSTAR or PSTAR as vertical coordinate. "}, {"default": "35.0", "units": "psu", "type_": "real", "name": "salinity_ref", "description": " Reference salinity used for converting fresh water flux to salt flux. "}, {"default": "-0.5", "units": "ppt", "type_": "real", "name": "max_delta_salinity_restore", "description": " When computing the restoring flux for salinity, we can define a maximum absolute value for the difference between salinity(k=1) and the restoring salinity from a dataset.  This approach is useful especially in NAtl western boundary, where poor Gulf Stream separation can lead to large salinity biases.  If restore too much the salinity field, we can spuriously transport large amounts of fresh water to the subpoloar gyre, thus impacting the overturning circulation too much. If max_delta_salinity_restore < 0.0, then will NOT provide a max to the delta salinity; will instead compute an unbounded restoring flux. Default max_delta_salinity_restore=-0.50. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "temp_correction_scale", "description": " A scale multiplying the flux correction for temperature. Default temp_correction_scale=0.0. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "salt_correction_scale", "description": " A scale multiplying the flux correction for salinity. Default salt_correction_scale=0.0. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "tau_x_correction_scale", "description": " A scale multiplying the flux correction for tau_x. Default tau_x_correction_scale=0.0. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "tau_y_correction_scale", "description": " A scale multiplying the flux correction for tau_y. Default tau_y_correction_scale=0.0. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "constant_hlf", "description": " Treat latent heat of fusion as a constant. Otherwise, use the TEOS-10 approach in which hlf is function of surface salinity. Note, TEOS-10 approach is only valid using Absolute Salinity and conservative temperature as the prognostic fields. Default constant_hlf = .true., which is the case for pre-TEOS-10 methods. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "constant_hlv", "description": " Treat latent heat of vaporization as a constant. Otherwise, use the TEOS-10 approach in which hlf is function of surface salinity. Note, TEOS-10 approach is only valid using Absolute Salinity and conservative temperature as the prognostic fields. Default constant_hlv = .true., which is the case for pre-TEOS-10 methods. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "avg_sfc_velocity", "description": " If set to true, the u and v fields passed up to the sea ice are averaged over a coupling interval. TRUE by default. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "avg_sfc_temp_salt_eta", "description": " If set to true, the t, s and sea_level fields passed up to the sea ice are averaged over a coupling interval. TRUE by default. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_full_patm_for_sea_level", "description": " The option use_full_patm_for_sea_level allows for the passing of the sea level including the full weight of sea ice back to the ice model.  This approach maintains the max weight on the liquid ocean according to the nml variable max_ice_thickness.  But it does allow the sea ice to know when there is actually more sea ice than that set by max_ice_thickness.  This option then provides for a negative feedback on the runaway growth of sea ice, since the full pressure acting to make the ice flow will be correctly felt.  This is a new option, and is not fully tested, So the default is use_full_patm_for_sea_level=.false "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is do_bitwise_exact_sum=.true. in order to ensure answers do not change when alter processors.  But if wish to enhance the efficiency of coupled ocean-ice models that use one of the global normalization options zero_net_salt_restore        =.true. zero_net_salt_correction     =.true. zero_net_water_restore       =.true. zero_net_water_correction    =.true. zero_net_water_coupler       =.true. zero_net_water_couple_restore=.true. then one may wish to consider setting do_bitwise_exact_sum=.false. "}], "filename": "src/mom5/ocean_core/ocean_sbc.F90"}, {"namelist": "ocean_thickness_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "rescale_mass_to_get_ht_mod", "description": " Expedient to allow for the computation of ht_mod. in the case when initialize_zero_eta=.true.  Here, we run the pressure based model with a rescaled mass that is sufficient to maintain non-negative dzt, at least for a short period.  This allows for one to run a day integration to produce ht_mod. rescale_mass_to_get_ht_mod=.true. will produce spurious results in general due to problems with the pressure gradient computation.  So it is not recommended for more than initial day or so. Default rescale_mass_to_get_ht_mod=.false. "}, {"default": "'energetic'", "units": null, "type_": "character(len=32)", "name": "thickness_method", "description": " To determine whether use energetic method or finite volume method to compute the thickness of a grid cell. Options are thickness_method=energetic or thickness_method=finitevolume. There is little overall difference in results for pbot and eta. However, it has been found that for realistic bottom topography simulations, the vertical velocity component is very noisy with the finitevolume approach.  So this approach is considered experimental.  The default is thickness_method='energetic'. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "linear_free_surface", "description": " For debugging, set the thickness of top cell in geopotential model to time independent values. This option is needed if use the kappa_sort diagnostic. Default linear_free_surface=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "full_step_topography", "description": " For case where with to only have the dzt be determined by the full step bottom topography. This nml option is provided only for backwards compatibility with older mom experiments using the full step topog. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "enforce_positive_dzt", "description": " For cases where wish to run model even with negative thickness. Default enforce_positive_dzt=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module_detail", "description": " For debugging pressure coordinate models. Lots of grid information printed. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_rho0_profile", "description": " To read in an initial rho0(z) profile to assist in defining the initial settings for the pressure increments dst, for use in setting the pressure-based vertical coordinate grids.  Ideally, this profile is determined by the level averaged density in the initial conditions.  Note that it is essential to have rho0_profile have a sensible value at all depths even if there is no water there, since there are places where we divide by rho0_profile in rock.  Also, be mindful that with denser water at depth, the pressure levels will be coarser at depth than if using the trivial density profile rho0(k)=rho0. This option is experimental, so it is recommended that user maintain the default read_rho0_profile=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "pbot0_simple", "description": " For testing purposes, have this option compute pbot0=g*rho0*ht with rho0= constant.  Default pbot0_simple=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "initialize_zero_eta", "description": " For pressure-based models, we can (with some work) initialize the model to have a zero surface height.  The recomended approach is to allow the surface height to be whatever it wants to be, and let adjustments smooth it over time.  Default initialize_zero_eta=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_rescale_rho0_mask", "description": " For reading in a basin mask of use to re-define rho0 in isolated regions such as the Black Sea.  This is used for modifying the definition of the pressure or pstar levels during the initialization of the thicknesses dst.  This approach is appropriate in general, but has only been tested when modify the pressure levels within a fully enclosed basin. Default read_rescale_rho0_mask=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "rescale_rho0_mask_gfdl", "description": " For specifying the rescale_rho0_mask based on reading in the GFDL regional mask. Default rescale_rho0_mask_gfdl=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "update_dzwu_k0", "description": " A bug in certain versions of MOM4p1 was present, whereby Thickness%dzwu(i,j,k=0) was never updated, except for GEOPOTENTIAL vertical coordinates.  This logical, whose default is update_dzwu_k0=.true., is provided for legacy purposes. To test the older results, have update_dzwu_k0=.false. "}, {"default": "25", "units": null, "type_": "integer", "name": "max_num_bad_print", "description": " Maximum bad grid cells printout for identifying problematic simulations. Default max_num_bad_print=25. "}, {"default": "1.0", "units": null, "type_": "real", "name": "rescale_rho0_value", "description": " Fractional value for rescaling rho0 in the a region. Default rescale_rho0_value=1.0. "}, {"default": "-1.0", "units": null, "type_": "real", "name": "rescale_rho0_basin_label", "description": " For rescaling rho0 in a basin with a number rescale_rho0_basin_label. For the Black Sea using GFDL basin masks in OM3, rescale_rho0_basin_label=7.0. Default rescale_rho0_basin_label=-1.0 "}, {"default": "5.0", "units": "m", "type_": "real", "name": "thickness_dzt_min_init", "description": " For determining a modified bottom depth array that is required to ensure pressure model, based on initial in-situ density, retains a nontrivial bottom cell thickness in the case when initialize_zero_eta=0.0 Default thickness_dzt_min_init=5.0. "}, {"default": "1.0", "units": "m", "type_": "real", "name": "thickness_dzt_min", "description": " Minimum dzt set when enforce_positive_dzt set true. Default thickness_dzt_min=1.0. "}, {"default": "0.01", "units": "m", "type_": "real", "name": "depth_min_for_sigma", "description": " For sigma coordinates, have minimum depth so that have layers defined globally.  Masks will zero out results over land, but for numerics it is useful to compute everywhere. Default depth_min_for_sigma=0.01. "}, {"default": "1.e-5", "units": null, "type_": "real", "name": "epsilon_init_thickness", "description": " For determining how strict we are to check for the thickness of a column when initializing pressure based vertical coordinate models. "}], "filename": "src/mom5/ocean_core/ocean_thickness.F90"}, {"namelist": "ocean_topog_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "flat_bottom", "description": " For debugging, it is often useful to over-ride the grid spec file and simply make the domain flat bottom. "}, {"default": "50", "units": null, "type_": "integer", "name": "flat_bottom_kmt", "description": " Number of depth levels to use for the flat_bottom option. "}, {"default": "5500.0", "units": null, "type_": "real", "name": "flat_bottom_ht", "description": " Depth to make the flat_bottom. "}, {"default": "1.0", "units": null, "type_": "real", "name": "min_thickness", "description": " min_thickness is only used for Mosaic grid. Since there is no kmt available in mosaic grid, need to set min_thickness to configure kmt based on ht and zw. Default min_thickness=1.0 metre. "}, {"default": "0", "units": null, "type_": "integer", "name": "kmt_recompute_offset", "description": " To recompute the kmt array based on min_thickness, with an offset determined by kmt_recompute_offset.  Default kmt_recompute_offset=0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "kmt_recompute", "description": " To recompute the kmt array based on min_thickness.  This step is not recommended in general, since it can modify the kmt array which may be in the grid spec file. But it may be of use for specialized situations, such as when you wish to use the same topography file with a refined vertical resolution. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "write_topog", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}], "filename": "src/mom5/ocean_core/ocean_topog.F90"}, {"namelist": "ocean_velocity_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "adams_bashforth_third", "description": " For a third order treatment of the velocity advection. This is stable and so needs no temporal dissipation (Section 2.3.6 of Durran).  This is the model default. "}, {"default": "0.6", "units": "dimensionless", "type_": "real", "name": "adams_bashforth_epsilon", "description": " Dimensionless parameter for 2nd order Adams-Bashforth implementation of velocity advection.  Values between 0.5 and 1.0 are recommended. Value of 0.5 leads to second order accurate, but it is formally weakly unstable (Durran, Section 2.3.4). "}, {"default": ".true.", "units": null, "type_": "logical", "name": "update_velocity_via_uprime", "description": " When updating the velocity, this method first computes uprime as the updated velocity minus the barotropic pressure gradient. This approach is motivated from the rigid lid approach, in which the surface pressure was never used to update the barotropic fields. With the explicit free surface, we have the choice to update the full velocity field, with the barotropic contributions to the pressure field resulting from a time average in the external mode algorithm.  This approach is for testing only, and it has been found to be unstable for many cases.  update_velocity_via_uprime=.true. uses the older aproach, in which the udrho,vdrho fields are taken from the external mode module.  update_velocity_via_uprime=.false. only takes the time averaged pressure from the external mode, and thus updates the full velocity and so recomputes the udrho,vdrho fields.  Default update_velocity_via_uprime=.true. The case of update_velocity_via_uprime=.false. is for testing only. It is not supported for general use. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency", "description": " For debugging. Will freeze the baroclinic velocity  fields. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency_explicit_a", "description": " For debugging. Will not use explicit-a part of the tendency. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency_explicit_b", "description": " For debugging. Will not use explicit-b part of the tendency. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency_implicit", "description": " For debugging. Will not use implicit part of the tendency. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "truncate_velocity", "description": " Truncate the baroclinic velocity to a maximum value.  Useful for cases where the initial spin-up initiates spuriously large model velocities that would otherwise cause the model to blow-up. Also can be used as a very simple \"polar filter\" in cases where have spherical coordinates and wish to avoid using the traditional polar filters. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "truncate_verbose", "description": " For verbose printout "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "truncate_velocity_lat", "description": " Latitude poleward of which we truncate the velocity. Useful in cases when wish to truncate the velocity only in polar regions. Default is 0.0 "}, {"default": "1.0", "units": "meter/sec", "type_": "real", "name": "truncate_velocity_value", "description": " Speed above which will truncate the baroclinic velocity "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_constant_velocity", "description": " For running with time independent constant velocity. For use with idealized cases. Default=.false. "}, {"default": "0.0", "units": "meter/sec", "type_": "real", "name": "constant_u", "description": " For running with use_constant_velocity. Set the i-velocity component to this value. Default constant_u=0.0 "}, {"default": "0.0", "units": "meter/sec", "type_": "real", "name": "constant_v", "description": " For running with use_constant_velocity. Set the j-velocity component to this value. Default constant_v=0.0 "}, {"default": "2.0", "units": null, "type_": "real", "name": "max_cgint", "description": " Maximum internal gravity wave speed--used for diagnosing conservative estimate of stable time steps. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}], "filename": "src/mom5/ocean_core/ocean_velocity.F90"}, {"namelist": "ocean_velocity_advect_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_velocity_advect_horz", "description": " For debugging, it is often useful to remove horizontal advection of velocity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_velocity_advect_vert", "description": " For debugging, it is often useful to remove vertical advection of velocity. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "velocity_advect_centered", "description": " For using the standard second order centered method for computing the advection of linear momentum. This is the default: velocity_advect_centered=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "velocity_advect_upwind", "description": " For using the first order upwind method for computing the advection of linear momentum. Default: velocity_advect_upwind=.false. "}], "filename": "src/mom5/ocean_core/ocean_velocity_advect.F90"}, {"namelist": "oda_nml ", "items": [{"default": "100000", "units": null, "type_": "integer", "name": "max_profiles", "description": " Size of allocation for profile data "}, {"default": "100", "units": null, "type_": "integer", "name": "max_sfc_obs", "description": " Size of allocation for surface observations "}, {"default": "'NO_ASSIM'", "units": null, "type_": "character(len=8)", "name": "assim_method", "description": " Options are: Var2d, EAKF and NO_ASSIM "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_iau", "description": " Incremental analysis update (evenly distribute increments between calls to ODA.) "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_convect_adjust", "description": " Adjust for gravitational instability in model after applying increments. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "save_omf_snaps", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "save_oma_snaps", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "nk_asm", "description": " Bottom model level for data mask "}, {"default": "-90.0", "units": null, "type_": "real", "name": "assim_start_lat", "description": " Southern data mask  boundary "}, {"default": "90.0", "units": null, "type_": "real", "name": "assim_end_lat", "description": " Northern data mask  boundary "}, {"default": "24", "units": null, "type_": "integer", "name": "assim_interval", "description": " Time between calls to oda (hours) "}, {"default": null, "units": null, "type_": "integer(2)", "name": "assim_layout", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}], "filename": "src/mom5/ocean_core/oda_driver.F90"}]}, {"directory": "src/mom5/ocean_diag", "namelists": [{"namelist": "ocean_adv_vel_diag_nml", "items": [{"default": "-1", "units": "dimensionless", "type_": "integer", "name": "diag_step", "description": " Number of time steps between which compute the diagnostics. "}, {"default": "100.0", "units": "dimensionless", "type_": "real", "name": "max_cfl_value", "description": " Critical value for Courant number, above which the model will be brought down. "}, {"default": "10.0", "units": "dimensionless", "type_": "real", "name": "large_cfl_value", "description": " Large value for Courant number, above which will write some diagnostics. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "verbose_cfl", "description": " For printing out lots of information about regions of large Courant numbers. "}], "filename": "src/mom5/ocean_diag/ocean_adv_vel_diag.F90"}, {"namelist": "ocean_drifters_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to run this module. Default use_this_module=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "output_interval", "description": " Interval in timesteps between drifter writes "}], "filename": "src/mom5/ocean_diag/ocean_drifters.F90"}, {"namelist": "ocean_tracer_diag_nml", "items": [{"default": "30.0", "units": "days", "type_": "real", "name": "tracer_conserve_days", "description": " Number of days between which compute the tracer conservation diagnostics. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_diagnose_mixingA", "description": " Set true for help with debugging the diagnostic for mixing. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_diagnose_mixingB", "description": " Set true for more help with debugging the diagnostic for mixing. Lots of output. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_diagnose_mixingC", "description": " Set true for more help with debugging the diagnostic for mixing. Lots of output. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_diagnose_mixingD", "description": " Set true for more help with debugging the diagnostic for mixing. Lots of output. "}, {"default": "1e28", "units": "kg/m^3/m", "type_": "real", "name": "rho_grad_max", "description": " max vertical density gradient (kg/m^3/m) used in computing kappa sorted "}, {"default": "1e-5", "units": "kg/m^3/m", "type_": "real", "name": "rho_grad_min", "description": " min vertical density gradient (kg/m^3/m) used in computing kappa sorted in the diagnostic mixing sorted. "}, {"default": "0", "units": null, "type_": "integer", "name": "smooth_kappa_sort", "description": " Number of 1-2-1 smooths applied to kappa_sort "}, {"default": "-1", "units": "dimensionless", "type_": "integer", "name": "diag_step", "description": " Number of time steps between which compute the diagnostics. "}, {"default": "0.0003", "units": "m/s^2", "type_": "real", "name": "buoyancy_crit", "description": " Critical buoyancy difference relative to surface for computing mixed layer depth. Default buoyancy_crit=0.0003. "}, {"default": "2.0", "units": "degC", "type_": "real", "name": "dtheta_crit", "description": " Critical temperature difference relative to surface for computing mixed_layer_depth_dtheta . Default dtheta_crit=2.0. "}, {"default": "1.004867", "units": null, "type_": "real", "name": "psu2ppt", "description": " The preTEOS10 EOS used in MOM requires salinity to use the Practical Salinity Scale (pss).  This scale is also known as the Practical Salinity Unit (psu).  However, salinity as an absolute concentration in parts per thousand is more convenient to use when performing budget analyses such as in this module. Conversion between pss and ppt depends on the precise ratio of ions in the seawater. Hence, the conversion is not constant. However, it is close to a constant, as reported in Jackett etal (2004).  For purposes of budgets, we take this conversion as a constant. The conversion is  s(ppt) = psu2ppt * s(psu)  where again s(psu) is what MOM carries as its prognostic salinity field when preTEOS10 EOS is used.  Jackett etal (2004), correcting a type in equation (53) of Feistel (2003), report that  s(ppt) = 1.004867 * s(psu)  "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "frazil_factor", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_mld", "description": " Smooth the diagnosed mixed layer depth. Default smooth_mld=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_mld_for_subduction", "description": " Smooth the diagnosed mixed layer depth to be used for subduction diagnostics. Default smooth_mld_for_subduction=.true. "}], "filename": "src/mom5/ocean_diag/ocean_tracer_diag.F90"}, {"namelist": "ocean_tracer_util_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "rebin_onto_rho_all_values", "description": " Set true to if wish to bin all values into density classes, even those cells whose density is outside the max and min range of the density bins.  The default is rebin_onto_rho_all_values=.true., which means those cells with extreme density values will be included. This default is consistent with the default computation of transport_on_nrho. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_diagnose_mass_of_layer", "description": " To help debug the algorithm to diagnose mass of fluid within a neutral density layer. Default:  debug_diagnose_mass_of_layer=.false. "}, {"default": "1e-5", "units": null, "type_": "real", "name": "epsln_diagnose_mass_of_layer", "description": " Relative mass difference allowable between layer and level total mass. Default: epsln_diagnose_mass_of_layer=1e-4. "}], "filename": "src/mom5/ocean_diag/ocean_tracer_util.F90"}, {"namelist": "ocean_velocity_diag_nml", "items": [{"default": "-1", "units": "dimensionless", "type_": "integer", "name": "diag_step", "description": " Number of time steps between which compute the diagnostics. "}, {"default": "-1", "units": null, "type_": "integer", "name": "energy_diag_step", "description": " Perform energy analysis every n timesteps (1==every time step). This diagnostic is expensive, so should be used sparingly during production runs. "}, {"default": "100", "units": "dimensionless", "type_": "integer", "name": "land_cell_num_max", "description": " Maximum number of land cells where will printout nonzero velocity points. Default land_cell_num_max=100. "}, {"default": "100.0", "units": "dimensionless", "type_": "real", "name": "max_cfl_value", "description": " Critical value for Courant number, above which the model will be brought down. "}, {"default": "10.0", "units": "dimensionless", "type_": "real", "name": "large_cfl_value", "description": " Large value for Courant number, above which will write some diagnostics. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "verbose_cfl", "description": " For printing out lots of information about regions of large Courant numbers. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For some debugging purposes "}], "filename": "src/mom5/ocean_diag/ocean_velocity_diag.F90"}]}, {"directory": "src/mom5/ocean_param/gotm-4.0/turbulence", "namelists": [{"namelist": "kpp", "items": [{"default": null, "units": null, "type_": "REALTYPE", "name": "Ric", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "kpp_interior", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "clip_mld", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/kpp.F90"}, {"namelist": "scnd", "items": [{"default": null, "units": null, "type_": "integer", "name": "scnd_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "kb_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "epsb_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "scnd_coeff", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cc1", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "keps", "items": [{"default": null, "units": null, "type_": "REALTYPE", "name": "ce1", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "ce2", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "ce3minus", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "ce3plus", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sig_k", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sig_e", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "sig_peps", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "turb_param", "items": [{"default": null, "units": null, "type_": "REALTYPE", "name": "cm0_fix", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "Prandtl0_fix", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cw", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "compute_kappa", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "kappa", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "compute_c3", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "ri_st", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "length_lim", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "galp", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "const_num", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "const_nuh", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "k_min", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "eps_min", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "kb_min", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "epsb_min", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "bc", "items": [{"default": null, "units": null, "type_": "integer", "name": "k_ubc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "k_lbc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "kb_ubc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "kb_lbc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "psi_ubc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "psi_lbc", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "ubc_type", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "lbc_type", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "generic", "items": [{"default": null, "units": null, "type_": "logical", "name": "compute_param", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_m", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_n", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_p", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cpsi1", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cpsi2", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cpsi3minus", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "cpsi3plus", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sig_kpsi", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sig_psi", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_d", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_alpha", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "gen_l", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "iw", "items": [{"default": null, "units": null, "type_": "integer", "name": "iw_model", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "alpha", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "klimiw", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "rich_cr", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "numiw", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "nuhiw", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "numshear", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "turbulence", "items": [{"default": null, "units": null, "type_": "integer", "name": "turb_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "tke_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "len_scale_method", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "stab_method", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}, {"namelist": "my", "items": [{"default": null, "units": null, "type_": "REALTYPE", "name": "e1", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "e2", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "e3", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sq", "description": null}, {"default": null, "units": null, "type_": "REALTYPE", "name": "sl", "description": null}, {"default": null, "units": null, "type_": "integer", "name": "my_length", "description": null}, {"default": null, "units": null, "type_": "logical", "name": "new_constr", "description": null}], "filename": "src/mom5/ocean_param/gotm-4.0/turbulence/turbulence.F90"}]}, {"directory": "src/mom5/ocean_param/lateral", "namelists": [{"namelist": "ocean_bih_friction_nml", "items": [{"default": "'general'", "units": null, "type_": "character(len=10)", "name": "bih_friction_scheme", "description": " To determine the biharmonic friction scheme: \"const\" or \"general\" "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}], "filename": "src/mom5/ocean_param/lateral/ocean_bih_friction.F90"}, {"namelist": "ocean_bih_tracer_nml", "items": [{"default": "0.0e10", "units": "m^4/sec", "type_": "real", "name": "abih", "description": " This is the value for the space-time constant biharmonic diffusivity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM diffusivity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tracer_mix_micom", "description": " If .true., then the diffusivity is set according to a velocity scale times the cube of the grid spacing. It is based on an approach recommended by Eric Chassignet that is used in the Miami Isopycnal Model. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module "}, {"default": ".false.", "units": null, "type_": "logical", "name": "horz_z_diffuse", "description": " To compute fluxes along surfaces of constant depth. This operation must necessarily be approximate for the two cases (i) non-geopotential vertical coordinates, (2) next to partial bottom step topography.  There are cases where use of this operator can lead to spurious creation of extrema due to truncation errors associated with the \"slope\" term. The option to use horz_z_diffuse=.true. is maintained for legacy purposes alone. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "horz_s_diffuse", "description": " To compute diffusion along surfaces of constant vertical s-coordinate. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_diffusivity_mask", "description": " Allows for reading of a mask that to apply diffusivity only in selected regions. Default read_diffusivity_mask=.false. "}], "filename": "src/mom5/ocean_param/lateral/ocean_bih_tracer.F90"}, {"namelist": "ocean_bihcgrid_friction_nml", "items": [{"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_iso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky isotropic viscosity. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_aniso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky anisotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity. "}, {"default": "0.2", "units": null, "type_": "real", "name": "eq_vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_lat_micom", "description": " Equatorial latitude band (degrees) within which the MICOM viscosity is set according to eq_vel_micom_iso and eq_vel_micom_aniso. "}, {"default": "0.0", "units": null, "type_": "real", "name": "equatorial_zonal_lat", "description": " Latitudinal band to use the zonal friction orientation. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_zonal", "description": " Orient the anisotropic friction within a latitudinal band according to zonal direction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_boundary_scaling", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_boundary_scaling_read", "description": null}, {"default": "2.e-8", "units": null, "type_": "real", "name": "ncar_vconst_4", "description": null}, {"default": "3", "units": null, "type_": "integer", "name": "ncar_vconst_5", "description": null}, {"default": "1", "units": null, "type_": "integer", "name": "ncar_rescale_power", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "neptune", "description": " Set to true for computing friction relative to Neptune barotropic velocity. Default neptune=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neptune_smooth", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed neptune velocity scale. Default neptune_smooth=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "neptune_smooth_num", "description": " Number of smoothing passes for neptune velocity. Default neptune_smooth_num=1. "}, {"default": "4.2e3", "units": "m", "type_": "real", "name": "neptune_length_eq", "description": " Length scale used to compute Neptune velocity at equator. "}, {"default": "17.0e3", "units": "m", "type_": "real", "name": "neptune_length_pole", "description": " Length scale used to compute Neptune velocity at pole. "}, {"default": "100.0", "units": "m", "type_": "real", "name": "neptune_depth_min", "description": " Minimum depth scale used for computing Neptune velocity. Default neptune_depth_min=100.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_side_drag_friction", "description": " For converting friction at U-cells next to walls into a drag law, as per Deremble et al. Use cdbot_array from ocean_core/ocean_bbc.F90 to compute drag force. Default use_side_drag_friction=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "side_drag_friction_scaling", "description": " Dimensionless scaling used for cdbot_array when setting side drag friction. So the effective side dragy coefficient is side_drag_friction_scaling*cdbot_array. Default side_drag_friction_scaling=1.0. "}, {"default": "1.0", "units": "N/m^2", "type_": "real", "name": "side_drag_friction_max", "description": " Maximum magnitude of the side drag induced friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations in ocean_bbc. Default side_drag_friction_max=1.0. "}, {"default": "10.0", "units": "m/s", "type_": "real", "name": "side_drag_friction_uvmag_max", "description": " Maximum magnitude of horizontal velocity used to compute the side drag friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_uvmag_max=10.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}], "filename": "src/mom5/ocean_param/lateral/ocean_bihcgrid_friction.F90"}, {"namelist": "ocean_bihcst_friction_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module.  Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}, {"default": "0.0", "units": "m^4/sec", "type_": "real", "name": "abih", "description": " This is the value for the space-time constant biharmonic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "eq_vel_micom", "description": " Velocity scale that is used for computing the MICOM viscosity within a latitude band surrounding the equator.  This is useful for some models of enhanced equatorial resolution that can maintain numerical integrity in this region with less friction than outside the tropical band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_lat_micom", "description": " Equatorial latitude band (degrees) within which the MICOM viscosity is set according to eq_vel_micom. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "velocity_mix_micom", "description": " If .true., then the viscosity is set according to a velocity scale times the cube of the grid spacing. It is based on an approach recommended by Eric Chassignet that is used in the Miami Isopycnal Model. "}], "filename": "src/mom5/ocean_param/lateral/ocean_bihcst_friction.F90"}, {"namelist": "ocean_bihgen_friction_nml", "items": [{"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_iso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky isotropic viscosity. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_aniso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky anisotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity. "}, {"default": "0.2", "units": null, "type_": "real", "name": "eq_vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_lat_micom", "description": " Equatorial latitude band (degrees) within which the MICOM viscosity is set according to eq_vel_micom_iso and eq_vel_micom_aniso. "}, {"default": "0.01", "units": "m/sec", "type_": "real", "name": "vel_micom_bottom", "description": " Velocity scale that is used for computing the MICOM viscosity for 5point Laplacian at the bottom. "}, {"default": "0.0", "units": null, "type_": "real", "name": "equatorial_zonal_lat", "description": " Latitudinal band to use the zonal friction orientation. "}, {"default": "1.0", "units": "dimensionless", "type_": "real", "name": "visc_crit_scale", "description": " Scaling factor used to determine the critical viscosity, above which the viscosity is not allowed to reach. Use visc_crit_scale < 1.0 for cases where the visc_crit from linear stability allows for still too large of a viscosity.  Use visc_crit_scale>1.0 when wish to allow for larger viscosity. Default is visc_crit_scale=1.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_zonal", "description": " Orient the anisotropic friction within a latitudinal band according to zonal direction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bottom_5point", "description": " To alleviate problems with small partial cells, it is often necessary to reduce the operator to the traditional 5-point Laplacian at the ocean bottom.  This logical implements this mixing. Default bottom_5point=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_boundary_scaling", "description": " To enhance the velocity scale used in western boundaries for the isotropic and anisotropic  background viscosities, we compute a scaling using the algorithm from the laplacian NCAR anisotropic scheme. Default ncar_boundary_scaling=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_boundary_scaling_read", "description": " To read in the ncar boundary scaling field rather than generating it during initialization.  Generating during initialization can be a bottle-neck on fine resolution models since there are some global 2d fields needed.  So if the rescaling is produced once and then saved, it can be read in during subsequent runs without incurring the slowdown of re-generating the scalings. Default ncar_boundary_scaling_read=.false. "}, {"default": "2.e-8", "units": "1/cm", "type_": "real", "name": "ncar_vconst_4", "description": " Inverse damping length for exponential falloff of the velocity scale as move eastward away from western boundary. Default ncar_vconst_4=2.e-8. "}, {"default": "3", "units": "dimensionless", "type_": "integer", "name": "ncar_vconst_5", "description": " For determining number of grid points in boundary calculation. Default ncar_vconst_5=3. "}, {"default": "1", "units": "dimensionless", "type_": "integer", "name": "ncar_rescale_power", "description": " For determining rescaling of the viscosity so to enhance the friction near the western boundaries. Default ncar_rescale_power=1. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neptune", "description": " Set to true for computing friction relative to Neptune barotropic velocity. Default neptune=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neptune_smooth", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed neptune velocity scale. Default neptune_smooth=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "neptune_smooth_num", "description": " Number of smoothing passes for neptune velocity. Default neptune_smooth_num=1. "}, {"default": "4.2e3", "units": "m", "type_": "real", "name": "neptune_length_eq", "description": " Length scale used to compute Neptune velocity at equator. Default neptune_length_eq= 4.2e3 from Maltrud and Holloway. "}, {"default": "17.0e3", "units": "m", "type_": "real", "name": "neptune_length_pole", "description": " Length scale used to compute Neptune velocity at pole. Default neptune_length_pole= 17.0e3 from Maltrud and Holloway. "}, {"default": "100.0", "units": "m", "type_": "real", "name": "neptune_depth_min", "description": " Minimum depth scale used for computing Neptune velocity. Default neptune_depth_min=100.0 from Maltrud and Holloway. "}, {"default": "1.0", "units": null, "type_": "real", "name": "neptune_scaling", "description": " Overall scaling parameter to help tune neptune. Default neptune_scaling=1.0 "}, {"default": "0.0", "units": null, "type_": "real", "name": "visc_diverge_scaling", "description": " Dimensionless scaling used for divergence based viscosity. Default visc_diverge_scaling=0.0 turns off the scheme. visc_diverge_scaling=10.0 produces sensible viscosities for 1-degree model.  May need tuning for different resolutions. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_side_drag_friction", "description": " For converting friction at U-cells next to walls into a drag law, as per Deremble et al. Use cdbot_array from ocean_core/ocean_bbc.F90 to compute drag force. Default use_side_drag_friction=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "side_drag_friction_scaling", "description": " Dimensionless scaling used for cdbot_array when setting side drag friction. So the effective side dragy coefficient is side_drag_friction_scaling*cdbot_array. Default side_drag_friction_scaling=1.0. "}, {"default": "1.0", "units": "N/m^2", "type_": "real", "name": "side_drag_friction_max", "description": " Maximum magnitude of the side drag induced friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_max=1.0. "}, {"default": "10.0", "units": "m/s", "type_": "real", "name": "side_drag_friction_uvmag_max", "description": " Maximum magnitude of horizontal velocity used to compute the side drag friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_uvmag_max=10.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_aiso_bih_back", "description": null}], "filename": "src/mom5/ocean_param/lateral/ocean_bihgen_friction.F90"}, {"namelist": "ocean_lap_friction_nml", "items": [{"default": "'general'", "units": null, "type_": "character(len=10)", "name": "lap_friction_scheme", "description": " To determine the laplacian friction scheme: \"const\" or \"general\" "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}], "filename": "src/mom5/ocean_param/lateral/ocean_lap_friction.F90"}, {"namelist": "ocean_lap_tracer_nml", "items": [{"default": "0.0e3", "units": "m^2/sec", "type_": "real", "name": "alap", "description": " This is the value for the space-time constant Laplacian diffusivity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM diffusivity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tracer_mix_micom", "description": " If .true., then the diffusivity is set according to a velocity scale times the grid spacing. It is based on an approach recommended by Eric Chassignet that is used in the Miami Isopycnal Model (MICOM). "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose writes during initialization "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "horz_z_diffuse", "description": " To compute diffusion along surfaces of constant depth. This operation must necessarily be approximate for the two cases (i) non-geopotential vertical coordinates, (2) next to partial bottom step topography.  There are cases where use of this operator can lead to spurious creation of extrema due to truncation errors associated with the \"slope\" term. For most cases where lateral diffusion is required, we will want it to be \"diffusive\" in the sense that no extrema are created.  So the default is horz_z_diffuse=.false. The option to use horz_z_diffuse=.true. is maintained for legacy purposes alone. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "horz_s_diffuse", "description": " To compute diffusion along surfaces of constant vertical s-coordinate. This operation is ensured of obtaining a smoothing operator that does not create extrema. It is the default for this reason. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_diffusivity_mask", "description": " Allows for reading of a mask that to apply diffusivity only in selected regions. Default read_diffusivity_mask=.false. "}], "filename": "src/mom5/ocean_param/lateral/ocean_lap_tracer.F90"}, {"namelist": "ocean_lapcgrid_friction_nml", "items": [{"default": "2.0", "units": "dimensionless", "type_": "real", "name": "k_smag_iso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky isotropic viscosity. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_aniso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky anisotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_lat_micom", "description": " Equatorial latitude band (degrees) within which the MICOM viscosity is set according to eq_vel_micom_iso and eq_vel_micom_aniso. "}, {"default": "0.0", "units": null, "type_": "real", "name": "equatorial_zonal_lat", "description": " Latitudinal band to use the zonal friction orientation. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_zonal", "description": " Orient the anisotropic friction within a latitudinal band according to zonal direction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_no_smag", "description": " Turn smag off within equatorial_zonal_lat region. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "viscosity_scale_by_rossby", "description": " To scale down the laplacian viscosity according to the relative scale of the horizontal grid and the first baroclinic Rossby radius. This is a useful scheme for models that resolve the Rossby radius in the lower latitudes, and so presumably do not wish to have much laplacian friction, whereas the higher latitudes need more friction.  Default viscosity_scale_by_rossby=.false. "}, {"default": "2.0", "units": null, "type_": "real", "name": "viscosity_scale_by_rossby_power", "description": " The power used to determine the viscosity scaling function. Default viscosity_scale_by_rossby_power=2.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "restrict_polar_visc", "description": " For restricting the background viscosity poleward of a latitude.  This method may be useful for coupling to an ice model in which case the horizontal viscosity may need to be a bit smaller to maintain time step constraints.  This is because the effective friction is larger than that just within the ocean. "}, {"default": "60.0", "units": null, "type_": "real", "name": "restrict_polar_visc_lat", "description": " Latitude poleward of which we restrict the viscosity. "}, {"default": "0.35", "units": null, "type_": "real", "name": "restrict_polar_visc_ratio", "description": " Ratio of the normal critical value that we limit the viscosity to be no greater than.  If restrict_polar_visc_ratio=1.0 then there is no special limitation of the viscosity beyond that of the one-dimensional stability constraint. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "divergence_damp", "description": " To damp the divergence field. "}, {"default": "0.0", "units": "m/s", "type_": "real", "name": "divergence_damp_vel_micom", "description": " Velocity scale to set the viscosity used with divergence damping. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neptune", "description": " Set to true for computing friction relative to Neptune barotropic velocity. Default neptune=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neptune_smooth", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed neptune velocity scale. Default neptune_smooth=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "neptune_smooth_num", "description": " Number of smoothing passes for neptune velocity. Default neptune_smooth_num=1. "}, {"default": "1.2e3", "units": "m", "type_": "real", "name": "neptune_length_eq", "description": " Length scale used to compute Neptune velocity at equator. "}, {"default": "3.0e3", "units": "m", "type_": "real", "name": "neptune_length_pole", "description": " Length scale used to compute Neptune velocity at pole. "}, {"default": "100.0", "units": "m", "type_": "real", "name": "neptune_depth_min", "description": " Minimum depth scale used for computing Neptune velocity. Default neptune_depth_min=100.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_side_drag_friction", "description": " For converting friction at U-cells next to walls into a drag law, as per Deremble et al. Use cdbot_array from ocean_core/ocean_bbc.F90 to compute drag force. Default use_side_drag_friction=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "side_drag_friction_scaling", "description": " Dimensionless scaling used for cdbot_array when setting side drag friction. So the effective side dragy coefficient is side_drag_friction_scaling*cdbot_array. Default side_drag_friction_scaling=1.0. "}, {"default": "1.0", "units": "N/m^2", "type_": "real", "name": "side_drag_friction_max", "description": " Maximum magnitude of the side drag induced friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations in ocean_bbc. Default side_drag_friction_max=1.0. "}, {"default": "10.0", "units": "m/s", "type_": "real", "name": "side_drag_friction_uvmag_max", "description": " Maximum magnitude of horizontal velocity used to compute the side drag friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_uvmag_max=10.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}], "filename": "src/mom5/ocean_param/lateral/ocean_lapcgrid_friction.F90"}, {"namelist": "ocean_lapcst_friction_nml", "items": [{"default": "0e5", "units": "m^2/sec", "type_": "real", "name": "alap", "description": " This is the value for the space-time constant Laplacian viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM viscosity. "}, {"default": "60.", "units": null, "type_": "real", "name": "alap_taper_start_lat", "description": null}, {"default": "90.", "units": null, "type_": "real", "name": "alap_taper_end_lat", "description": null}, {"default": "30.", "units": null, "type_": "real", "name": "alap_taper_min_fac", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "alap_taper_hi_lats", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "velocity_mix_micom", "description": " If .true., then the viscosity is set according to a velocity scale times the cube of the grid spacing. It is based on an approach recommended by Eric Chassignet that is used in the Miami Isopycnal Model. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "read_alap", "description": null}], "filename": "src/mom5/ocean_param/lateral/ocean_lapcst_friction.F90"}, {"namelist": "ocean_lapgen_friction_nml", "items": [{"default": "2.0", "units": "dimensionless", "type_": "real", "name": "k_smag_iso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky isotropic viscosity. "}, {"default": "0.0", "units": "dimensionless", "type_": "real", "name": "k_smag_aniso", "description": " This is the dimensionless Smagorinsky coefficient used to set the scale of the Smagorinsky anisotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_iso", "description": " Velocity scale that is used for computing the MICOM isotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_vel_micom_aniso", "description": " Velocity scale that is used for computing the MICOM anisotropic viscosity within a user specified equatorial band. "}, {"default": "0.0", "units": null, "type_": "real", "name": "eq_lat_micom", "description": " Equatorial latitude band (degrees) within which the MICOM viscosity is set according to eq_vel_micom_iso and eq_vel_micom_aniso. "}, {"default": "0.0", "units": null, "type_": "real", "name": "equatorial_zonal_lat", "description": " Latitudinal band to use the zonal friction orientation. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_zonal", "description": " Orient the anisotropic friction within a latitudinal band according to zonal direction. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "equatorial_no_smag", "description": " Turn smag off within equatorial_zonal_lat region. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bottom_5point", "description": " To alleviate problems with small partial cells, it is often necessary to reduce the operator to the traditional 5-point Laplacian at the ocean bottom.  This logical implements this mixing. Default bottom_5point=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "viscosity_scale_by_rossby", "description": " To scale down the laplacian viscosity according to the relative scale of the horizontal grid and the first baroclinic Rossby radius. This is a useful scheme for models that resolve the Rossby radius in the lower latitudes, and so presumably do not wish to have much laplacian friction, whereas the higher latitudes need more friction.  Default viscosity_scale_by_rossby=.false. "}, {"default": "2.0", "units": null, "type_": "real", "name": "viscosity_scale_by_rossby_power", "description": " The power used to determine the viscosity scaling function. Default viscosity_scale_by_rossby_power=2.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "restrict_polar_visc", "description": " For restricting the background viscosity poleward of a latitude.  This method may be useful for coupling to an ice model in which case the horizontal viscosity may need to be a bit smaller to maintain time step constraints.  This is because the effective friction is larger than that just within the ocean. "}, {"default": "60.0", "units": null, "type_": "real", "name": "restrict_polar_visc_lat", "description": " Latitude poleward of which we restrict the viscosity. "}, {"default": "0.35", "units": null, "type_": "real", "name": "restrict_polar_visc_ratio", "description": " Ratio of the normal critical value that we limit the viscosity to be no greater than.  If restrict_polar_visc_ratio=1.0 then there is no special limitation of the viscosity beyond that of the one-dimensional stability constraint. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "divergence_damp", "description": " To damp the divergence field. "}, {"default": "0.0", "units": "m/s", "type_": "real", "name": "divergence_damp_vel_micom", "description": " Velocity scale to set the viscosity used with divergence damping. "}, {"default": "1.e7", "units": "cm^2/sec", "type_": "real", "name": "vconst_1", "description": " Background viscosity for NCAR algorithm. "}, {"default": "0.0", "units": null, "type_": "real", "name": "vconst_2", "description": " For NCAR viscosity algorithm. "}, {"default": "0.16", "units": null, "type_": "real", "name": "vconst_3", "description": " For NCAR viscosity algorithm. "}, {"default": "2.e-8", "units": "1/cm", "type_": "real", "name": "vconst_4", "description": " For NCAR viscosity algorithm. "}, {"default": "3", "units": null, "type_": "integer", "name": "vconst_5", "description": " For NCAR viscosity algorithm. "}, {"default": "1.e7", "units": "cm^2/sec", "type_": "real", "name": "vconst_6", "description": " For NCAR viscosity algorithm. "}, {"default": "100.0", "units": "cm/sec", "type_": "real", "name": "vconst_7", "description": " For NCAR viscosity algorithm. "}, {"default": "45.0", "units": "degrees", "type_": "real", "name": "vconst_8", "description": " For NCAR viscosity algorithm. "}, {"default": "1500.e2", "units": "cm", "type_": "real", "name": "visc_vel_scale_length", "description": " For NCAR viscosity algorithm: efolding depth for depth dependent background viscosity. Default visc_vel_scale_length=1500.e2 cm "}, {"default": ".false.", "units": null, "type_": "logical", "name": "viscosity_ncar", "description": " Anisotropic background viscosities used by NCAR. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "viscosity_ncar_2000", "description": " Anisotropic background viscosities used by NCAR, using the formulation as of 2000.  Default viscosity_ncar_2000=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "viscosity_ncar_2007", "description": " Anisotropic background viscosities used by NCAR, using the formulation as of 2007.  Default viscosity_ncar_2007=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_ncar_A", "description": " Sets f_perp=f_para for debugging purposes with the NCAR scheme. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_ncar_B", "description": " Sets f_para=f_perp for debugging purposes with the NCAR scheme. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_isotropic_off_equator", "description": " Polewards of equatorial_zonal_lat, revert NCAR scheme to isotropic "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_only_equatorial", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "ncar_isotropic_at_depth", "description": " Sets the NCAR scheme to be isotropic beneath a chosen depth. "}, {"default": "4000.0", "units": "m", "type_": "real", "name": "ncar_isotropic_depth", "description": " Sets the NCAR scheme to be isotropic beneath this chosen depth. "}, {"default": "1e4", "units": "m2/sec", "type_": "real", "name": "ncar_isotropic_at_depth_visc", "description": " Sets the NCAR scheme to be isotropic beneath this chosen depth, with minimum viscosity set according to this value. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neptune", "description": " Set to true for computing friction relative to Neptune barotropic velocity. Default neptune=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neptune_smooth", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed neptune velocity scale. Default neptune_smooth=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "neptune_smooth_num", "description": " Number of smoothing passes for neptune velocity. Default neptune_smooth_num=1. "}, {"default": "1.2e3", "units": "m", "type_": "real", "name": "neptune_length_eq", "description": " Length scale used to compute Neptune velocity at equator. "}, {"default": "3.0e3", "units": "m", "type_": "real", "name": "neptune_length_pole", "description": " Length scale used to compute Neptune velocity at pole. "}, {"default": "100.0", "units": "m", "type_": "real", "name": "neptune_depth_min", "description": " Minimum depth scale used for computing Neptune velocity. Default neptune_depth_min=100.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_side_drag_friction", "description": " For converting friction at U-cells next to walls into a drag law, as per Deremble et al. Use cdbot_array from ocean_core/ocean_bbc.F90 to compute drag force. Default use_side_drag_friction=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "side_drag_friction_scaling", "description": " Dimensionless scaling used for cdbot_array when setting side drag friction. So the effective side dragy coefficient is side_drag_friction_scaling*cdbot_array. Default side_drag_friction_scaling=1.0. "}, {"default": "1.0", "units": "N/m^2", "type_": "real", "name": "side_drag_friction_max", "description": " Maximum magnitude of the side drag induced friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_max=1.0. "}, {"default": "10.0", "units": "m/s", "type_": "real", "name": "side_drag_friction_uvmag_max", "description": " Maximum magnitude of horizontal velocity used to compute the side drag friction. This parameter can be useful especially for pressure models where the bottom cells can be quite thin and subject to sporadic large magnitudes.  We do the same thing with bottom drag calculations. Default side_drag_friction_uvmag_max=10.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging by printing checksums. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "async_domain_update", "description": null}, {"default": "10", "units": null, "type_": "integer", "name": "blocksize", "description": null}], "filename": "src/mom5/ocean_param/lateral/ocean_lapgen_friction.F90"}, {"namelist": "ocean_mixdownslope_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "mixdownslope_weight_far", "description": " To place more weight on points further from central point.  This may be done to enhance properties getting downslope.  Default is mixdownslope_weight_far=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_mixdownslope_mask", "description": " For reading in a mask that selects regions of the domain where mixdownslope is allowed to function (mask=1) or not to function (mask=0). Default read_mixdownslope_mask=.false., whereby mixdownslope_mask is set to tmask(k=1). "}, {"default": ".false.", "units": null, "type_": "logical", "name": "mixdownslope_mask_gfdl", "description": " For modifying the mixdownslope mask based on reading in the GFDL regional mask. Default mixdownslope_mask_gfdl=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "mixdownslope_npts", "description": " Number of horizontally distant points used in search downslope. Note: it is not possible to have mixdownslope_npts greater than or equal to the computational domain extents, as this would require updates across multiple processors. Default mixdownslope_npts=1. "}, {"default": "1", "units": null, "type_": "integer", "name": "mixdownslope_width", "description": " Width of the re-weighting function used to emphasize points further along in the search for exchange points.  Default mixdownslope_width=1. "}, {"default": "0.25", "units": null, "type_": "real", "name": "mixdownslope_frac_central", "description": " Fraction of the central cell that participates in downslope mixing in any particular direction.  Default mixdownslope_frac_central=0.25 "}], "filename": "src/mom5/ocean_param/lateral/ocean_mixdownslope.F90"}, {"namelist": "ocean_sigma_transport_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "tmask_sigma_on", "description": " IF .true. then masks out fluxes passing into the sigma layer, except those associated with sigma transport. Typically set to .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "sigma_diffusion_on", "description": " For using sigma diffusion. Default is true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sigma_advection_on", "description": " For using sigma advection. Default is false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "sigma_advection_sgs_only", "description": " In many cases, adding the resolved transport to the sigma-advective transport produces a tremendous level of noise at the bottom.  The problem is that there are grid-scale features that may cause large jumps in whether the velocity should be added or not, depending on the logic of the scheme.  For this reason, it may be prudent to remove the resolved velocity from that contributing to the sigma transport scheme. Note that its removal from sigma transport does not remove the contributions of the resolved velocity from the resolved advective transport arising from ocean_tracer_advect_mod. It simply removes it from the added transport arising in the sigma transport module. Default is sigma_advection_sgs_only=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "sigma_advection_check", "description": " If true, then will only include the resolved advection velocity in the sigma-layer if the direction of transport is downslope favorable for enhancing deep density. IF false, then will include the velocity regardless. This option aims to reduce the large divergences that occur for the case when only include the velocity if it is favorable for deep water getting more dense. Default is sigma_advection_check=.true. "}, {"default": "1.0e3", "units": "m^2/sec", "type_": "real", "name": "sigma_diffusivity", "description": " Sigma tracer diffusivity for use if not using micom diffusivity. "}, {"default": "1.0e-6", "units": "dimensionless", "type_": "real", "name": "sigma_diffusivity_ratio", "description": " When flow along sigma surface is stable (i.e., heavy parcels are below lighter parcels) then sigma diffusivity is reduced by sigma_diffusivity_ratio from the case where heavy parcels are above lighter parcels. "}, {"default": "100.0", "units": "meter", "type_": "real", "name": "thickness_sigma_max", "description": " Maximum thickness of the bottom sigma layer. "}, {"default": "10.0", "units": "meter", "type_": "real", "name": "thickness_sigma_min", "description": " Minimum thickness of the bottom sigma layer. "}, {"default": "50.0", "units": "meter", "type_": "real", "name": "thickness_sigma_layer", "description": " Initial thickness of the bottom sigma layer. "}, {"default": "0.50", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM diffusivity. "}, {"default": "1.e-4", "units": "inverse seconds", "type_": "real", "name": "campingoose_mu", "description": " Dissipation rate for the bottom friction.  Campin and Goosse suggest campingoose_mu=10^-4 "}, {"default": "0.3333", "units": "dimensionless", "type_": "real", "name": "campingoose_delta", "description": " Fraction of a grid cell participating in the overflow process. Campin and Goosse suggest campingoose_delta=1/3. "}, {"default": ".10", "units": "m/s", "type_": "real", "name": "sigma_umax", "description": " Maximum downslope speed allowed in sigma layer. In some cases, the model will be unstable if sigma_umax is too large. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tracer_mix_micom", "description": " If .true., then the sigma diffusivity is set according to a velocity scale times the grid spacing. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "sigma_just_in_bottom_cell", "description": " For just having sigma layer in the bottom cell, as in mom4p0. This option must be .false. in order to use sigma_advection_on=.true. Default sigma_just_in_bottom_cell=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_sigma_thickness", "description": " To smooth the sigma thickness. This may be needed especially for case with sigma advection, in which case the thickness can become noisy. Default is smooth_sigma_thickness=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_sigma_velocity", "description": " To smooth the sigma advective transport velocity. Default is smooth_sigma_velocity=.true. "}, {"default": "0.2", "units": null, "type_": "real", "name": "smooth_velmicom", "description": null}], "filename": "src/mom5/ocean_param/lateral/ocean_sigma_transport.F90"}, {"namelist": "ocean_submesoscale_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "submeso_skew_flux", "description": " For computing the tendency as convergence of skew flux. This is the recommended method. Default submeso_skew_flux=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_advect_flux", "description": " For computing the tendency as convergence of advective flux. This approach uses either a flux limited sweby advection or first order upwind, both of which ensure that the resulting tendency will not create extrema in the tracer field. Default submeso_advect_flux=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "submeso_advect_upwind", "description": " For computing the tendency as convergence of a first order advective flux. Default submeso_advect_upwind=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_advect_sweby", "description": " For computing the tendency as convergence of a sweby advective flux. This routine is incomplete and has a bug. Default submeso_advect_sweby=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_advect_limit", "description": " For limiting the value of the horizontal transports to be less than a velocity scale set by limit_psi_velocity_scale. This option is not needed if limit_psi=.true. Default submeso_advect_limit=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_advect_zero_bdy", "description": " For removing the advective transport next to boundaries. This is useful since computation of the advective transport velocity components can be problematic next to boundaries. Default submeso_advect_zero_bdy=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "submeso_limit_flux", "description": " For limiting the fluxes arising from submeso scheme, according to tmask_limit. When reach a point where tmask_limit=1.0, then set the submeso flux for this cell to zero. Default submeso_limit_flux=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_hblt_constant", "description": " For running with a constant boundary layer depth. This for the case when not using a realistic mixed layer scheme.  Default use_hblt_constant=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_hblt_equal_mld", "description": " For using the diagnosed mld as the hblt for submeso. This is useful for those test models that do not have a mixed layer scheme enabled, such as KPP, where the mixed layer scheme provides a boundary layer depth.  In this case, it is sensible to employ the diagnosed mixed layer depth for the submeso scheme. Additionally, in general it is more physical to use the mld than the KPP hblt as the depth over which the submesoscale eddies act.  Hence, default use_hblt_equal_mld=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_hblt", "description": " For smoothing on the submeso bldepth field. This is useful since the bldepth obtained from KPP or diagnosed mld can have some grid noise. Default smooth_hblt=.false. since this agrees with legacy. Note that this scheme fails to reproduce across processor layout, so it remains broken. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_psi", "description": " For doing a horizontal 1-2-1 smoothing on the psix_horz and psiy_horz fields. Default smooth_psi=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_advect_transport", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed uhrho_et_submeso and vhrho_nt_submeso fields. Default smooth_advect_transport=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "front_length_deform_radius", "description": " To compute the front length using the mixed layer deformation radius. Default front_length_deform_radius=.true.  Note, will have a floor on the variable front length set by the nml setting for front_length_const. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "limit_psi", "description": " For limiting the magnitude of psi in order to reduce possibility of model crashes. Rescales the full psi to maintain vertical structure but to keep overall magnitude within bounds. Default limit_psi=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_psi_legacy", "description": " For computing psi using older legacy methods. These methods are not ideal, and can be problematic depending on nml settings for the limiters and smoothers. This option is retained only for legacy purposes. Default use_psi_legacy=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_diffusion", "description": " For computing a horizontal diffusive flux in the boundary layer as determined by the strength of the vector streamfunction. Default submeso_diffusion=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "submeso_diffusion_biharmonic", "description": " The default submeso diffusion is Laplacian. However, one may wish to use a biharmonic mixing operator instead. Default submeso_diffusion_biharmonic=.false. "}, {"default": "0.5", "units": "metre/sec", "type_": "real", "name": "limit_psi_velocity_scale", "description": " Velocity scale used to limit the value of psi when limit_psi=.true. Default limit_psi_velocity_scale=5.0 "}, {"default": "0.07", "units": "dimensionless", "type_": "real", "name": "coefficient_ce", "description": " The dimensionless coefficient from the Fox-Kemper etal scheme. They recommend setting coefficient_ce between 0.06 and 0.08. Default coefficient_ce=0.07. "}, {"default": "86400.0", "units": "seconds", "type_": "real", "name": "time_constant", "description": " Timescale to mix momentum across the mixed layer. Default time_constant=86400.0 = 1day. "}, {"default": "5e3", "units": "metre", "type_": "real", "name": "front_length_const", "description": " Take constant horizontal length scale of submesoscale front. Default front_length_const=5e3. "}, {"default": "100.0", "units": "metre", "type_": "real", "name": "constant_hblt", "description": " The boundary layer depth for the case when use_hblt_constant=.true. Default constant_hblt=100.0. "}, {"default": "0.0", "units": "metre", "type_": "real", "name": "minimum_hblt", "description": " For setting a floor to the hblt used for submesoscale scheme. Default minimum_hblt=0.0. "}, {"default": "1.0", "units": "dimensionless", "type_": "real", "name": "submeso_diffusion_scale", "description": " A dimensionless scaling to be used for scaling up or down the effects from horizontal diffusion in the boundary layer. Default submeso_diffusion_scale=1.0. "}, {"default": "4", "units": "dimensionless", "type_": "integer", "name": "min_kblt", "description": " The minimum number of vertical cells in the surface boundary layer that are required in order to compute the submesoscale streamfunction. Default min_kblt=4.  Need at least three to fit a parabola with zero streamfunction at the top and bottom of the boundary layer. "}, {"default": "1200", "units": null, "type_": "integer", "name": "diag_step", "description": " Number of time steps between computing max bottom value for wrho_bt_submeso. Default diag_step=1200. "}, {"default": "2", "units": null, "type_": "integer", "name": "smooth_psi_num", "description": " Number of iterations for the smooothing of psi. Default smooth_psi_num=2. "}, {"default": "2", "units": null, "type_": "integer", "name": "smooth_advect_transport_num", "description": " Number of iterations for the smooothing of horizontal transport. Default smooth_advect_transport_num=2. "}, {"default": "2", "units": null, "type_": "integer", "name": "smooth_hblt_num", "description": " Number of iterations for the smooothing of bldepth. Default smooth_hblt_num=1. "}], "filename": "src/mom5/ocean_param/lateral/ocean_submesoscale.F90"}]}, {"directory": "src/mom5/ocean_param/neutral", "namelists": [{"namelist": "ocean_nphysics_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "use_nphysicsA", "description": " For using the nphysicsA method of neutral physics, based on that developed in MOM4.0.  This scheme is more robust and recommended for general use.  Default use_nphysicsA=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_nphysicsB", "description": " For using the nphysicsB method of neutral physics.  This method is experimental, and is not recommended for general use. Default use_nphysicsB=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_nphysicsC", "description": " For using the nphysicsC method of neutral physics.  This method is experimental, and is not recommended for general use. Default use_nphysicsC=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default use_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For printing starting and ending checksums for restarts Default debug_this_module=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics.F90"}, {"namelist": "ocean_nphysics_diff_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "agm_const", "description": null}, {"default": "1.0e3", "units": null, "type_": "real", "name": "agm", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_micom", "description": null}, {"default": "0.0", "units": null, "type_": "real", "name": "agm_micom_vel", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_lat_bands", "description": null}, {"default": "-999.", "units": null, "type_": "real", "name": "agm_lat_bands_boundary", "description": null}, {"default": "1.0", "units": null, "type_": "real", "name": "agm_lat_bands_ratio", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure", "description": null}, {"default": "2.e3", "units": null, "type_": "real", "name": "agm_max", "description": null}, {"default": "2.e2", "units": null, "type_": "real", "name": "agm_min", "description": null}, {"default": "2.0", "units": null, "type_": "real", "name": "agm_scaling", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_rate_len2", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_grid_scaling", "description": null}, {"default": "2.0", "units": null, "type_": "real", "name": "agm_grid_scaling_power", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_smooth_space", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_smooth_time", "description": null}, {"default": "10.0", "units": null, "type_": "real", "name": "agm_damping_time", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_n2_scale", "description": null}, {"default": "1e3", "units": null, "type_": "real", "name": "agm_n2_scale_coeff", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_n2_scale_nref_cst", "description": null}, {"default": "0.004", "units": null, "type_": "real", "name": "agm_n2_scale_buoy_freq", "description": null}, {"default": "100.0", "units": null, "type_": "real", "name": "agm_rate_upper_depth", "description": null}, {"default": "2000.0", "units": null, "type_": "real", "name": "agm_rate_lower_depth", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_eady", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_baroclinic", "description": null}, {"default": "0.004", "units": null, "type_": "real", "name": "agm_rate_baro_buoy_freq", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_smooth_vert", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_smooth_horiz", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_cap", "description": null}, {"default": "0.5", "units": null, "type_": "real", "name": "agm_rate_cap_scale", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_ave_mixed", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_zave", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_rate_eden_greatbatch", "description": null}, {"default": "0.07", "units": null, "type_": "real", "name": "agm_rate_eg_alpha", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_length_eden_greatbatch", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_length_cap", "description": null}, {"default": "50e3", "units": null, "type_": "real", "name": "agm_length_max", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_length_fixed", "description": null}, {"default": "50.e3", "units": null, "type_": "real", "name": "agm_length", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_length_rossby", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_length_bczone", "description": null}, {"default": "10", "units": null, "type_": "integer", "name": "agm_bczone_max_pts", "description": null}, {"default": "1.4e-6", "units": null, "type_": "real", "name": "agm_bczone_crit_rate", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "aredi_equal_agm", "description": null}, {"default": "1.0e3", "units": null, "type_": "real", "name": "aredi", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "aredi_fixed", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "aredi_grid_scaling", "description": null}, {"default": "2.0", "units": null, "type_": "real", "name": "aredi_grid_scaling_power", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_horiz_mix_bdy", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "ah_micom", "description": null}, {"default": "0.0", "units": null, "type_": "real", "name": "ah_micom_vel", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "ah_const", "description": null}, {"default": "0.0", "units": null, "type_": "real", "name": "ah", "description": null}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_diff.F90"}, {"namelist": "ocean_nphysics_flux_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "diffusion_all_explicit", "description": " To compute K33 explicitly in time.  This setting is meant only for debugging tests, since in general the simulation will go unstable. Default diffusion_all_explicit=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_physics_limit", "description": " Revert to horizontal diffusion when tracer falls outside specified range. Default neutral_physics_limit=.true., so to keep tracers from going too far outside of physical range. "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_flux.F90"}, {"namelist": "ocean_nphysics_new_nml", "items": [{"default": null, "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be set .true. to use this module. Default use_this_module = .false. "}, {"default": "0.01", "units": null, "type_": "real", "name": "smax", "description": " Slope maximum parameter for setting behaviour of neutral physics. Default smax=0.01. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "drhodz_smooth_vert", "description": " For smoothing vertical density gradient before computing neutral slope.  Exercise caution if using this option. Default drhodz_smooth_vert=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "drhodz_smooth_horz", "description": " For smoothing vertical density gradient before computing neutral slope.  Exercise caution if using this option. Default drhodz_smooth_horz=.false. "}, {"default": "0.2", "units": "m/s", "type_": "real", "name": "vel_micom_smooth", "description": " For horizontal smoothing of drhodz before computing neutral slopes. Default vel_micom_smooth=0.2. "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_new.F90"}, {"namelist": "ocean_nphysics_skew_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "gm_transport", "description": " To compute tendency from GM skewsion. Default gm_transport=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bc_modes_transport", "description": " To compute tendency from GM skewsion using streamfunction established by baroclinic modes. Default bc_modes_transport=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "number_bc_modes", "description": " The number of baroclinic modes used to construct the eddy induced streamfunction when bc_modes_transport. Default number_bc_modes=1. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "regularize_transport", "description": " To reduce the magnitude of psi in regions of weak stratification, using the slope = smax_psi to set the overall scale of the max allowed for psi. Default regularize_transport=.true. "}, {"default": "0.01", "units": null, "type_": "real", "name": "smax_psi", "description": " Maximum slope used for setting the overall scale of a modal contribution to the parameterized transport. Default smax_psi=0.1. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bvp_transport", "description": " To compute tendency from GM skewsion using streamfunction established by a boundary value problem. Default bvp_transport=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bvp_constant_speed", "description": " For taking a constant speed to be used for the calculation of the BVP streamfunction. Default bvp_constant_speed=.false. "}, {"default": "0.0", "units": "m/s", "type_": "real", "name": "bvp_speed", "description": " For setting the speed weighting the second order derivative operator in the BVP streamfunction method: c^2 = max[bvp_min_speed, (bvp_speed-c_mode)^2]. If bvp_constant_speed, then  c^2 = bvp_speed^2. Default bvp_speed=0.0, in which case c^2 = c_mode^2. "}, {"default": "1", "units": null, "type_": "integer", "name": "bvp_bc_mode", "description": " The particular baroclinic mode used to construct the BVP streamfunction. If bvp_bc_mode=0, then will set bc_speed=0 when computing the BVP streamfunction. Default bvp_bc_mode=1. "}, {"default": "1.0", "units": "m/s", "type_": "real", "name": "bvp_min_speed", "description": " For setting a minimum speed for use with the calculation of the BVP streamfunction. We need  bvp_min_speed>0 to ensure that the second order derivative operator contributes to the calculation of the streamfunction. Default bvp_min_speed=0.1. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_transport", "description": " For doing a horizontal 1-2-1 smoothing on the psix and psiy fields. This is useful to reduce noise. Default smooth_psi=.true. "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_skew.F90"}, {"namelist": "ocean_nphysics_tensor_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "neutral_sine_taper", "description": null}, {"default": "0.0", "units": null, "type_": "real", "name": "turb_blayer_min", "description": null}, {"default": "100e3", "units": null, "type_": "real", "name": "rossby_radius_max", "description": null}, {"default": "15e3", "units": null, "type_": "real", "name": "rossby_radius_min", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "dm_taper", "description": null}, {"default": "0.05*.01", "units": null, "type_": "real", "name": "swidth", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_taper_diagonal", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "tmask_neutral_on", "description": null}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_tensor.F90"}, {"namelist": "ocean_nphysics_util_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "drhodz_mom4p1", "description": " For computing the vertical deriviative of locally referenced potrho as in the preferred MOM algorithm rather than the earlier mom4p0 approach. Default drhodz_mom4p1=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "drhodz_smooth_horz", "description": " For horizontal laplacian smoothing the vertical derivative of density prior to its use in computing the neutral slopes. This smoothing helps to produce regularized slopes. Note that this option breaks the integrity of the triads and is thus NOT generally recommended. Default drhodz_smooth_horz=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "drhodz_smooth_vert", "description": " For vertical 1-2-1 smoothing the vertical derivative of density prior to its use in computing the neutral slopes. This smoothing helps to produce regularized slopes. Note that this option breaks the integrity of the triads and is thus NOT generally recommended. Default drhodz_smooth_vert=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": " For number of 1-2-1 passes through to smooth drhodz or eady_rate in vertical. Default num_121_passes=1. "}, {"default": "0.2", "units": "m/sec", "type_": "real", "name": "vel_micom_smooth", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in smoothing of drhodzb. Default vel_micom_smooth=0.2. "}, {"default": "1e-30", "units": "kg/m^3", "type_": "real", "name": "epsln_drhodz", "description": " For computing drhodz used in slope calculation. We must keep drhodz < 0 in order to maintain integrity of the quasi-Stokes streamfunction as well as computation of buoyancy frequency. Default epsln_drhodz=1e-30. "}, {"default": "1.0e3", "units": null, "type_": "real", "name": "aredi", "description": " Neutral diffusivity used for experiments using a constant diffusivity. "}, {"default": "1.0e3", "units": null, "type_": "real", "name": "agm", "description": " GM-skew diffusivity used for experiments using a constant diffusivity. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "aredi_equal_agm", "description": " Will set aredi_array=agm_array, over-riding any other specification of aredi_array. Default aredi_equal_agm=.true. "}, {"default": "0.01", "units": null, "type_": "real", "name": "smax", "description": " Value of the maximum neutral direction slope above which the neutral fluxes are either tapered to zero or saturated.  Typical value is smax=0.01 or smaller. "}, {"default": "0.05*.01", "units": null, "type_": "real", "name": "swidth", "description": " Width in slope over which use tanh with dm_taper scheme to taper fluxes in steep sloped regions. Typical value swidth=0.1*smax "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_horz_mix_bdy", "description": " If .true., then use a horizontal diffusivity in the neutral boundary layer. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom_bdy", "description": " Velocity scale that is used for computing the MICOM horizontal diffusivity within the neutral boundary layer. "}, {"default": "0.0", "units": "m^2/sec", "type_": "real", "name": "ah_bdy", "description": " Constant horizontal diffusivity for the boundary layer. Default ah_bdy=0.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bryan_lewis_aredi", "description": " Set bryan_lewis_aredi=.true. when want to have aredi a function of depth according to the Bryan and Lewis (1979) profile. Maintained for legacy purposes, and not recommended for new models. "}, {"default": "0.0", "units": null, "type_": "real", "name": "ahs", "description": " ahs = adjustable parameter at the surface for bryan_lewis_aredi "}, {"default": "0.0", "units": null, "type_": "real", "name": "ahb", "description": " ahb = adjustable parameter at the bottom for bryan_lewis_aredi "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_lat_bands", "description": null}, {"default": "-999.", "units": null, "type_": "real", "name": "agm_lat_bands_boundary", "description": null}, {"default": "1.0", "units": null, "type_": "real", "name": "agm_lat_bands_ratio", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "tracer_mix_micom", "description": " If .true., then the GM-skew diffusivity is set according to a velocity scale times the grid spacing. "}, {"default": "0.0", "units": "m/sec", "type_": "real", "name": "vel_micom", "description": " Velocity scale that is used for computing the MICOM diffusivity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_read_restart", "description": " For those cases with agm_closure=.false. where we wish to read in the agm_array from restart files and keep the value from the restart. This approach allows us to read in a spatially dependent agm_array that may have been computed from another integration, but to leave the coefficient static in time. Default agm_read_restart=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure", "description": " If .true. then will compute the GM-skew diffusivity as a function of the flow. The length scale is determined by the Rossby radius and the time scale is determined by the Eady growth rate.  Diffusivities are depth independent. "}, {"default": "2.0", "units": "dimensionless", "type_": "real", "name": "agm_closure_scaling", "description": " Dimensionless tuning parameter for computing flow dependent diffusivities. "}, {"default": "2.e3", "units": "m^2/sec", "type_": "real", "name": "agm_closure_max", "description": " Maximum GM diffusivity allowed when using agm_closure=.true. "}, {"default": "2.e2", "units": "m^2/sec", "type_": "real", "name": "agm_closure_min", "description": " Minimum GM diffusivity allowed when using agm_closure=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_length_fixed", "description": " Use fixed length scale for computing agm_closure diffusivity "}, {"default": "50.e3", "units": "meter", "type_": "real", "name": "agm_closure_length", "description": " Fixed length scale for use with agm_closure_fixed_length "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_length_rossby", "description": " For computing the agm_closure length scale according to Rossby radius. "}, {"default": "100e3", "units": "meter", "type_": "real", "name": "rossby_radius_max", "description": " Maximum Rossby radius used for agm_closure_length_rossby and the neutral_sine_taper. Default = 100e3 m. "}, {"default": "15e3", "units": "meter", "type_": "real", "name": "rossby_radius_min", "description": " Minimum Rossby Radius used for agm_closure_length_rossby and the neutral_sine_taper. Default = 15e3 m. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_length_bczone", "description": " For computing the agm_closure length scale according to radius of baroclinic zone. "}, {"default": "10", "units": null, "type_": "integer", "name": "bczone_max_pts", "description": " Max number of horizontal grid points for use in computing the baroclinic zone radius. "}, {"default": "1.4e-6", "units": "sec^-1", "type_": "real", "name": "agm_closure_bczone_crit_rate", "description": " Critical growth rate for determining width of the baroclinic zone. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_length_cap", "description": " For setting a maximum length scale for the agm_closure calculation. Default agm_closure_length_cap=.false. "}, {"default": "50e3", "units": "metre", "type_": "real", "name": "agm_closure_length_max", "description": " Maximum length scale used for computing agm_closure. Default agm_closure_length_max=50e3. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_n2_scale", "description": " For computing the agm coefficient using a 3-dimensional scaling by (N/Nref)^2, with N=buoyancy frequency and Nref the buoyancy frequency at the base of the neutral blayer. Default agm_closure_n2_scale=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_n2_scale_nref_cst", "description": " For taking the reference buoyancy frequency as agm_closure_buoy_freq for the (N/Nref)^2 scaling. Default agm_closure_n2_scale_nref_cst=.false. "}, {"default": "1e3", "units": "m^2/s", "type_": "real", "name": "agm_closure_n2_scale_coeff", "description": " Coefficient setting the scale for the diffusivity computed from agm_closure_n2_scale. Default agm_closure_n2_scale_coeff=1e3. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eden_greatbatch", "description": " For computing the agm_closure length scale according to minimum of the Rhines scale and the Rossby radius, and using 3d Eady growth rate. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eden_length_const", "description": " To set the length scale for agm_closure_eden_greatbatch to constant. Default agm_closure_eden_length_const=.false. "}, {"default": "200.0", "units": "dimensionless", "type_": "real", "name": "agm_closure_eden_gamma", "description": " For use in regularizing the growth rate used in the eden/greatbatch approach. Default agm_closure_eden_gamma=200. Setting to zero removes the regularization. "}, {"default": "10e3", "units": "metre", "type_": "real", "name": "agm_closure_eden_length", "description": " Length scale for use with agm_closure_eden_length_const=.true. Default agm_closure_eden_length=10e3. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "agm_closure_baroclinic", "description": " For computing the agm coefficient using only the vertically averaged magnitude of the horizontal density gradient (i.e., the \"baroclinicity\"). "}, {"default": "0.004", "units": "sec^-1", "type_": "real", "name": "agm_closure_buoy_freq", "description": " For computing the agm coefficient using only the vertically averaged horizontal density gradient, we need to specify a buoyancy frequency,  which is taken to be fixed over all space-time. "}, {"default": "100.0", "units": "m", "type_": "real", "name": "agm_closure_upper_depth", "description": " Upper depth where start the depth integration to compute the Eady growth rate and/or baroclinicity. "}, {"default": "2000.0", "units": "m", "type_": "real", "name": "agm_closure_lower_depth", "description": " Deeper depth where finish the depth integration to compute the Eady growth rate and/or baroclinicity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eady_smooth_vert", "description": " For vertical 1-2-1 smoothing the eady_rate Default agm_closure_eady_smooth=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eady_smooth_horz", "description": " For horizontal Laplacian smoothing of eady growth rate. Default agm_closure_eady_smooth_horz=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eady_cap", "description": " For capping the eady growth rate to avoid huge values. Default agm_closure_eady_cap=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_eady_ave_mixed", "description": " To set the Eady growth rate to its average within mixed layer region. This is used to avoid spuriously large values which often appear just in the upper regions of the ocean mixed layer. Default agm_closure_eady_ave_mixed=.false. "}, {"default": "0.5", "units": "dimensionless", "type_": "real", "name": "agm_closure_growth_scale", "description": " Dimensionless scaling used to set a maximum for agm_growth. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_smooth_space", "description": " For smoothing the agm diffusivity in space when nonconstant diffusivity used. Default is agm_smooth_space=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_smooth_time", "description": " For smoothing the agm diffusivity in time when nonconstant diffusivity used. Default is agm_smooth_time=.false. "}, {"default": "10.0", "units": "days", "type_": "real", "name": "agm_damping_time", "description": " The damping time used for time smoothing agm_array. Default agm_damping_time=10days. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "agm_closure_grid_scaling", "description": " For an overall scaling of the agm coefficient, according to the relative resolution of the grid and deformation radius. Default is agm_closure_grid_scaling=.false. "}, {"default": "2.0", "units": null, "type_": "real", "name": "agm_closure_grid_scaling_power", "description": " Power used to scale the agm_closure diffusivity. Default is agm_closure_grid_scaling_power=2.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "aredi_diffusivity_grid_scaling", "description": " For an overall scaling of the aredi coefficient, according to the relative resolution of the grid and deformation radius. This option is used only when aredi_equal_agm=.false. Default is aredi_diffusivity_grid_scaling=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "nphysics_util_zero_init", "description": " For Time%init=.true. and wishing to ensure starting with a clean suite of nphysics_util fields, even if ocean_neutral.res.nc exists. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "wdianeutral_smooth", "description": " For smoothing the diagnosed dianeutral velocity component using a horizontal 1-2-1 smoother. Default is wdianeutral_smooth=.true. "}, {"default": "1e-7", "units": "kg/m4", "type_": "real", "name": "epsln_drhodz_diagnostics", "description": " For drhodz used in calculation of dianeutral velocity component from cabbeling and thermobaricity. Default epsln_drhodz_diagnostics=1e-7. "}, {"default": ".01", "units": null, "type_": "real", "name": "smax_grad_gamma_scalar", "description": " For calculation of gradients of scalars along a neutral direction, then when abs(slope) > smax_grad_gamma_scalar, will compute the gradient using only the vertical scalar gradient, since the slopes are so large they are effectively infinite. Default smax_grad_gamma_scalar=.01 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_eta_tend_gm90", "description": " For smoothing the diagnosed contribution to steric sea level time tendency associated with the GM90 scheme. Default is smooth_eta_tend_gm90=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For printing starting and ending checksums for restarts "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_util.F90"}, {"namelist": "ocean_nphysics_util_new_nml", "items": [{"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": " For number of 1-2-1 passes through to smooth drhodz or eady_rate in vertical. Default num_121_passes=1. "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysics_util_new.F90"}, {"namelist": "ocean_nphysicsA_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "use_gm_skew", "description": " Must be true to use GM skewsion.  Set to false if wish to incorporate the \"GM-effect\" through form drag, as in ocean_form_drag module. Default use_gm_skew=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "dm_taper", "description": " Set to true to use the tanh tapering scheme of Danabasoglu and McWilliams. Default is true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "gkw_taper", "description": " Set to true to use the quadradic tapering scheme of Gerdes, Koberle, and Willebrand. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_physics_simple", "description": " If .true. then must have aredi_equal_agm=.true..  The horizontal fluxes are then computed as horizontal downgradient diffusive fluxes regardless the neutral slope. This approach precluds one from being able to have the GM-skew fluxes remain active in the steep sloped regions, thus shutting off their effects to reduce the slopes of isopycnals in convective and mixed layer regimes.  It is for this reason that neutral_physics_simple=.false. is the recommended default in MOM. "}, {"default": "0.0", "units": null, "type_": "real", "name": "turb_blayer_min", "description": " Minimum depth of a surface turbulent boundary layer used in the transition of the neutral physics fluxes to the surface.  Note that in MOM4.0, turb_blayer_min was always set to zero. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "neutral_blayer_diagnose", "description": " Diagnose properties of the neutral physics boundary layer, whether have neutral_linear_gm_taper or neutral_sine_taper true or not. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_linear_gm_taper", "description": " If .true. then with neutral_physics_simple=.false., will linearly taper GM skew fluxes towards the surface within regions of steep neutral slopes. This approach leads to a constant horizontal eddy-induced velocity in the steeply sloping regions and is recommended for realistic simulations. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_sine_taper", "description": " If .true. then with neutral_physics_simple=.false., will apply a sine-taper to GM and neutral diffusive fluxes in regions where the penetration depth of eddies is deeper than the grid point. This method is essential for fine vertical resolution grids. "}, {"default": ".false.", "units": "dimensionless", "type_": "logical", "name": "neutral_taper_diagonal", "description": " For cases with neutral_physics_simple=.false., then neutral_taper_diagonal=.true. will taper the diagonal pieces of the horizontal flux components when neutral slopes are steep. With neutral_taper_diagonal=.false., then the horizontal flux components will remain enabled for all slopes, thus producing horizontal downgradient diffusion in regions of vertical neutral directions. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tmask_neutral_on", "description": " If .true. then this logical reduces the neutral fluxes to horizontal/vertical diffusion next to boundaries. This approach has been found to reduce spurious extrema resulting from truncation of triads used to compute a neutral flux component. Default tmask_neutral_on=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "diffusion_all_explicit", "description": " To compute all contributions from neutral diffusion explicitly in time, including the K33 diagonal piece.  This approach is available only when have small time steps and/or running with just a single tracer.  It is for testing purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_physics_limit", "description": " When tracer falls outside a specified range, revert to horizontal diffusive fluxes at this cell. This is an ad hoc and incomplete attempt to maintain monotonicity with the neutral physics scheme. Default neutral_physics_limit=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For printing starting and ending checksums for restarts "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysicsA.F90"}, {"namelist": "ocean_nphysicsB_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "use_gm_skew", "description": " Must be true to use GM skewsion.  Set to false if wish to incorporate the \"GM-effect\" through form drag, as in ocean_form_drag module. Default use_gm_skew=.true. "}, {"default": "10.0", "units": "days", "type_": "real", "name": "neutral_damping_time", "description": " The damping time used for determining the effective surface boundary layer thickness from other portions of the model. Default neutral_damping_time=10days. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "nblayer_smooth", "description": " For smoothing the neutral blayer fields. This is useful when aiming to produce a smooth quasi-stokes streamfunction within the boundary layers. Default is nblayer_smooth=.true. "}, {"default": "0.2", "units": "m/sec", "type_": "real", "name": "vel_micom_smooth", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of neutral blayer fields. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "dm_taper", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "gkw_taper", "description": null}, {"default": "5", "units": null, "type_": "integer", "name": "surf_turb_thick_min_k", "description": " Minimum number of k-levels in surface turbulent boundary layer used in the transition of the neutral physics fluxes to the surface. Default surf_turb_thick_min_k = 2. "}, {"default": "50.0", "units": null, "type_": "real", "name": "surf_turb_thick_min", "description": " Minimum thickness of surface turbulent boundary layer used in the transition of the neutral physics fluxes to the surface. Default surf_turb_thick_min=20m. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "diffusion_all_explicit", "description": " To compute all contributions from neutral diffusion explicitly in time, including the K33 diagonal piece.  This approach is available only when have small time steps and/or running with just a single tracer.  It is for testing purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_physics_limit", "description": " When tracer falls outside a specified range, revert to horizontal diffusive fluxes at this cell. This is an ad hoc and incomplete attempt to maintain monotonicity with the neutral physics scheme. Default neutral_physics_limit=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tmask_neutral_on", "description": " If .true. then this logical reduces the neutral fluxes to horizontal/vertical diffusion next to boundaries. This approach has been found to reduce spurious extrema resulting from truncation of triads used to compute a neutral flux component.  Default tmask_neutral_on=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For printing starting and ending checksums for restarts "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysicsB.F90"}, {"namelist": "ocean_nphysicsC_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "smooth_advect_transport", "description": " For doing a horizontal 1-2-1 smoothing on the diagnosed uhrho_et_gm and vhrho_nt_gm fields. Default smooth_advect_transport=.true. "}, {"default": "2", "units": null, "type_": "integer", "name": "smooth_advect_transport_num", "description": " Number of iterations for the smooothing of horizontal transport. Default smooth_advect_transport_num=2. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_neutral_diffusion", "description": " To compute tendency from neutral diffusion. Default do_neutral_diffusion=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_gm_skewsion", "description": " To compute tendency from GM skewsion. Default do_gm_skewsion=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "gm_skewsion_modes", "description": " To compute tendency from GM skewsion using streamfunction established by baroclinic modes. Default gm_skewsion_modes=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "gm_skewsion_bvproblem", "description": " To compute tendency from GM skewsion using streamfunction established by a boundary value problem. Default gm_skewsion_bvproblem=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "number_bc_modes", "description": " The number of baroclinic modes used to construct the eddy induced streamfunction. Default number_bc_modes=1. "}, {"default": "1", "units": null, "type_": "integer", "name": "bvp_bc_mode", "description": " The particular baroclinic mode used to construct the BVP streamfunction. If bvp_bc_mode=0, then will set bc_speed=0 when computing the BVP streamfunction. Default bvp_bc_mode=1. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bvp_constant_speed", "description": " For taking a constant speed to be used for the calculation of the BVP streamfunction. Default bvp_constant_speed=.false. "}, {"default": "0.0", "units": "m/s", "type_": "real", "name": "bvp_speed", "description": " For setting the speed weighting the second order derivative operator in the BVP streamfunction method: c^2 = max[bvp_min_speed, (bvp_speed-c_mode)^2]. If bvp_constant_speed, then  c^2 = bvp_speed^2. Default bvp_speed=0.0, in which case c^2 = c_mode^2. "}, {"default": "0.1", "units": "m/s", "type_": "real", "name": "bvp_min_speed", "description": " For setting a minimum speed for use with the calculation of the BVP streamfunction. We need  bvp_min_speed>0 to ensure that the second order derivative operator contributes to the calculation of the streamfunction. Default bvp_min_speed=0.1. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "regularize_psi", "description": " To reduce the magnitude of psi in regions of weak stratification, using the slope = smax_psi to set the overall scale of the max allowed for psi. Default regularize_psi=.true. "}, {"default": "0.1", "units": null, "type_": "real", "name": "smax_psi", "description": null}, {"default": "1.e-10", "units": "kg/m4", "type_": "real", "name": "epsln_bv_freq", "description": " Minimum buoyancy frequency accepted for the computation of baroclinic modes. Default epsln_bv_freq=1e-10.  Note there is also a minimum drhodz set in ocean_density.F90 via the nml epsln_drhodz in that module.  We provide yet another minimum here in case we need an extra regularization for the amplitude of the baroclinic modes. "}, {"default": "1.e-6", "units": "m/s", "type_": "real", "name": "min_bc_speed", "description": " The minimum speed used for computing the baroclinic modes. Default min_bc_speed=1e-6 "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_psi", "description": " For doing a horizontal 1-2-1 smoothing on the psix and psiy fields. This is useful to reduce noise. Default smooth_psi=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_bc_modes", "description": " For doing a vertical 1-2-1 smoothing on the baroclinic modes prior to normalization.  This is useful to reduce noise. Default smooth_bc_modes=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bv_freq_smooth_vert", "description": " To smooth the buoyancy frequency for use in computing the baroclinic modes. Generally this field has already been smooted in ocean_density_mod, but we maintain the possibility of further smoothing here.  Default bv_freq_smooth_vert=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": " The number of 121 passes used to smooth buoyancy frequency when bv_freq_smooth_vert=.true.  Default num_121_passes=1. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "dm_taper", "description": " Set to true to use the tanh tapering scheme of Danabasoglu and McWilliams. Default is true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "gkw_taper", "description": " Set to true to use the quadradic tapering scheme of Gerdes, Koberle, and Willebrand. Default is false. "}, {"default": "0.0", "units": null, "type_": "real", "name": "turb_blayer_min", "description": " Minimum depth of a surface turbulent boundary layer used in the transition of the neutral diffusion fluxes to the surface.  Note that in mom4p0, turb_blayer_min was always set to zero. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_eddy_depth", "description": " Compute eddy_depth according to depth over which eddies feel the ocean surface. Default neutral_eddy_depth=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "tmask_neutral_on", "description": " If .true. then this logical reduces the neutral diffusive fluxes to horizontal/vertical diffusion next to boundaries. This approach has been found to reduce spurious extrema resulting from truncation of triads used to compute a neutral flux component. Default tmask_neutral_on=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "diffusion_all_explicit", "description": " To compute all contributions from neutral diffusion explicitly in time, including the K33 diagonal piece.  This approach is available only when have small time steps and/or running with just a single tracer.  It is for testing purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "neutral_physics_limit", "description": " When tracer falls outside a specified range, revert to horizontal diffusive fluxes at this cell. This is an ad hoc and incomplete attempt to maintain monotonicity with the neutral physics scheme. Default neutral_physics_limit=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_neutral_slopes_potrho", "description": " To compute the neutral slopes based on globally referenced potential density rather than locally referenced potential density. This approach is meant solely for sensitivity studies; it is not meant for realistic simulations. Default use_neutral_slopes_potrho=.false. "}, {"default": "2000.0", "units": "dbar", "type_": "real", "name": "neutral_slopes_potrho_press", "description": " The reference pressure used to compute neutral slopes when setting use_neutral_slopes_potrho=.true. Default neutral_slopes_potrho_press=2000.0 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For printing starting and ending checksums for restarts "}], "filename": "src/mom5/ocean_param/neutral/ocean_nphysicsC.F90"}]}, {"directory": "src/mom5/ocean_param/sources", "namelists": [{"namelist": "ocean_increment_eta_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "fraction_increment", "description": " For prescribing the fraction of the increment. applied to the restoring period.  Default fraction_increment=1.0 "}, {"default": "1", "units": null, "type_": "integer", "name": "days_to_increment", "description": " For specifying the amount of days to restore. Default days_to_increment=1 "}, {"default": "0", "units": null, "type_": "integer", "name": "secs_to_increment", "description": " For specifying the amount of seconds to restore. Default secs_to_increment=0 "}], "filename": "src/mom5/ocean_param/sources/ocean_increment_eta.F90"}, {"namelist": "ocean_increment_tracer_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "fraction_increment", "description": " For prescribing the fraction of the increment. applied to the restoring period.  Default fraction_increment=1.0 "}, {"default": "1", "units": null, "type_": "integer", "name": "days_to_increment", "description": " For specifying the amount of days to restore. Default days_to_increment=1 "}, {"default": "0", "units": null, "type_": "integer", "name": "secs_to_increment", "description": " For specifying the amount of seconds to restore. Default secs_to_increment=0 "}], "filename": "src/mom5/ocean_param/sources/ocean_increment_tracer.F90"}, {"namelist": "ocean_increment_velocity_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "fraction_increment", "description": " For prescribing the fraction of the increment. applied to the restoring period.  Default fraction_increment=1.0 "}, {"default": "1", "units": null, "type_": "integer", "name": "days_to_increment", "description": " For specifying the amount of days to restore. Default days_to_increment=1 "}, {"default": "0", "units": null, "type_": "integer", "name": "secs_to_increment", "description": " For specifying the amount of seconds to restore. Default secs_to_increment=0 "}], "filename": "src/mom5/ocean_param/sources/ocean_increment_velocity.F90"}, {"namelist": "ocean_momentum_source_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_rayleigh_damp_table", "description": " For reading in Rayleigh damping times from a table. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "rayleigh_damp_exp_from_bottom", "description": " For computing a Rayleigh damping time with largest at bottom and decaying towards surface. "}, {"default": "100.0", "units": "metre", "type_": "real", "name": "rayleigh_damp_exp_scale", "description": " Exponential decay scale from bottom upwards for computing the Rayleigh damping time. "}, {"default": "8.64e5", "units": null, "type_": "real", "name": "rayleigh_damp_exp_time", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose initialization information. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Needs to be true in order to use this scheme. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}], "filename": "src/mom5/ocean_param/sources/ocean_momentum_source.F90"}, {"namelist": "ocean_overexchange_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "overexch_weight_far", "description": " To place more weight on points further from central point.  This may be done to enhance properties getting downslope.  Default is overexch_weight_far=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "overexch_check_extrema", "description": " Check to be sure there are no global tracer extrema formed due to the overexch process. Note that this approach DOES NOT conserve tracer, so it is not generally recommended. Default overexch_check_extrema=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "overexch_npts", "description": " Number of points used in search for the exchange method. Default overexch_npts=1.  Note: it is not possible to have overexch_npts greater than or equal to the computational domain extents, as this would require updates across multiple processors. Default overexch_npts=1. "}, {"default": "1", "units": null, "type_": "integer", "name": "overexch_width", "description": " Width of the re-weighting function used to emphasize the points further along in the search for exchange points.  Default overexch_width=1. "}, {"default": "1.e-4", "units": "sec^-1", "type_": "real", "name": "overflow_mu", "description": " Dissipation rate for the bottom friction.  Campin and Goosse suggest overflow_mu=10^-4 "}, {"default": "0.3333", "units": "dimensionless", "type_": "real", "name": "overflow_delta", "description": " Fraction of a grid cell participating in the overflow process. Campin and Goosse suggest overflow_delta=1/3. "}, {"default": "1.0", "units": "m/s", "type_": "real", "name": "overflow_umax", "description": " Maximum downslope speed used for determining the exchange rate. Default overflow_umax=1.0. "}, {"default": "0.25", "units": null, "type_": "real", "name": "overexch_stability", "description": " Stability factor for determining the maximum overexch_flux. Default overexch_stability=0.25 "}, {"default": "4.0", "units": "metre", "type_": "real", "name": "overexch_min_thickness", "description": " Minimum bottom cell thickness allowed for use of this scheme. Have found that with very thin cells, the model can become very unstable.  Default overexch_min_thickness=4.0 "}], "filename": "src/mom5/ocean_param/sources/ocean_overexchange.F90"}, {"namelist": "ocean_overflow_nml", "items": [{"default": "'Sv'", "units": null, "type_": "character(len=32)", "name": "transport_units", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "no_return_flow", "description": " Set true to remove the Campin and Goose return flow \"piping\". Default no_return_flow=.false. to recover the standard approach from Campin and Goose. "}, {"default": "1.e-4", "units": "inverse seconds", "type_": "real", "name": "overflow_mu", "description": " Dissipation rate for the bottom friction.  Campin and Goosse suggest overflow_mu=10^-4 "}, {"default": "0.3333", "units": "dimensionless", "type_": "real", "name": "overflow_delta", "description": " Fraction of a grid cell participating in the overflow process. Campin and Goosse suggest overflow_delta=1/3. "}, {"default": "0.01", "units": "m/s", "type_": "real", "name": "overflow_umax", "description": " Maximum downslope speed. "}], "filename": "src/mom5/ocean_param/sources/ocean_overflow.F90"}, {"namelist": "ocean_overflow_OFP_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging.  Default is false. "}, {"default": "1.0", "units": null, "type_": "real", "name": "crit_Fr_geo_ofp", "description": " Maximum overflow speed at the source region Default is 3.0 m/s "}, {"default": "1.0", "units": null, "type_": "real", "name": "frac_exchange_src", "description": " Areal fraction of the overflow exchange at the source region Default is 1.0 "}, {"default": "2.0", "units": null, "type_": "real", "name": "max_ofp_speed", "description": " Maximum overflow speed [m^/s] Default is 2.0 "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_mass_ofp", "description": " Considering the mass source in the overflow process Default is .true. "}, {"default": "-1", "units": null, "type_": "integer", "name": "diag_step", "description": " Diagnostic time step for OFP. Default is diag_step = -1 The diagnostic output is saved in the ascii directory as the ascii format. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_entrainment_para_ofp", "description": " Considering the parameterization of entrainment process in the overflow process Default is .true. "}], "filename": "src/mom5/ocean_param/sources/ocean_overflow_OFP.F90"}, {"namelist": "ocean_rivermix_nml", "items": [{"default": "0.0", "units": "meter", "type_": "real", "name": "river_insertion_thickness", "description": " Thickness of the column over which to insert tracers from rivers. Default river_insertion_thickness=0.0 (all in top). "}, {"default": "0.0", "units": "meter", "type_": "real", "name": "runoff_insertion_thickness", "description": " Thickness of the column over which to insert tracers carried by liquid runoff. Default runoff_insertion_thickness=0.0 (all in top). "}, {"default": "0.0", "units": "meter", "type_": "real", "name": "calving_insertion_thickness", "description": " Thickness of the column over which to insert tracers carried by solid runoff. Default calving_insertion_thickness=0.0 (all in top). "}, {"default": "0.0", "units": "meter", "type_": "real", "name": "river_diffusion_thickness", "description": " Thickness of the column over which to diffuse tracers from rivers. "}, {"default": "5.0e-3", "units": "m^2/s", "type_": "real", "name": "river_diffusivity", "description": " Vertical diffusivity enhancement at river mouths which is applied to a depth of river_diffusion_thickness, with linear tapering to zero enhancement from the ocean surface to river_diffusion_thickness. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "river_diffuse_temp", "description": " Logical to determine if enhance vertical diffusion of temp at river mouths "}, {"default": ".false.", "units": null, "type_": "logical", "name": "river_diffuse_salt", "description": " Logical to determine if enhance vertical diffusion of salt and all other passive tracers at river mouths "}, {"default": ".true.", "units": null, "type_": "logical", "name": "discharge_combine_runoff_calve", "description": " Set discharge_combine_runoff_calve=.true. to discharge combined tracer carried by liquid and solid runoff. This approach is sensible when ocean assigns a tracer content to the liquid and solid runoff fields. The alternative is to have a land model that provides information about the tracer coming into the ocean from land water, in which case it is preferable to set discharge_combine_runoff_calve=.false., so to do the runoff and calving separately. Default discharge_combine_runoff_calve=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "do_bitwise_exact_sum", "description": " Set true to do bitwise exact global sum. When it is false, the global sum will be non-bitwise_exact, but will significantly increase efficiency. The default value is do_bitwise_exact_sum=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_all_in_top_cell", "description": " For debugging, by placing all in top cell, regardless value of river_insertion_thickness. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module_heat", "description": " For debugging, print global sum of heating rate by river water. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to enable this module.  Default=.true., since this is the only way that tracer in river water enters the ocean. "}], "filename": "src/mom5/ocean_param/sources/ocean_rivermix.F90"}, {"namelist": "ocean_riverspread_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to enable this module.  Default=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. Default=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "riverspread_diffusion", "description": " For spreading river water via a Laplacian diffusion operation. Default=.false. "}, {"default": "0", "units": null, "type_": "integer", "name": "riverspread_diffusion_passes", "description": " Number of diffusion passes applied to the runoff/calving array. Default riverspread_diffusion_passes = 0. "}, {"default": "0.2", "units": "m/sec", "type_": "real", "name": "vel_micom_smooth", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of river water. Default vel_micom_smooth=0.2. "}], "filename": "src/mom5/ocean_param/sources/ocean_riverspread.F90"}, {"namelist": "ocean_shortwave_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_shortwave_gfdl", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_shortwave_csiro", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_shortwave_jerlov", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_shortwave_ext", "description": null}], "filename": "src/mom5/ocean_param/sources/ocean_shortwave.F90"}, {"namelist": "ocean_shortwave_csiro_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_depth", "description": " If .true. then read in e folding depth for radiation attenuation. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "enforce_sw_frac", "description": " To ensure the shortwave fraction is monotonically decreasing with depth. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sw_pen_fixed_depths", "description": " To compute penetration assuming fixed depths via Grd%zw(k) depths. This is strictly incorrect when have undulating free surface or generatlized vertical coordinates.  This option is here for purposes of legacy, as this was done in MOM4.0 versions. The default is .false. "}, {"default": "20.0", "units": "mg/m^3", "type_": "real", "name": "depth_default", "description": " Default efolding depth = 20m. "}, {"default": "120.0", "units": "meter", "type_": "real", "name": "zmax_pen", "description": " Maximum depth of penetration of shortwave radiation. Below this depth, shortwave penetration is exponentially small and so is ignored. "}, {"default": "0.0", "units": null, "type_": "real", "name": "sw_frac_top", "description": " The fraction of shortwave radiation that should be incorporated into the sw_source array at k=1.  The generic treatment in MOM is to assume that shortwave radiation is already contained inside the T_prog(index_temp)%stf field. Hence, to avoid double counting, sw_frac(k=0)=sw_frac_top should=0.0. If one removes shortwave from stf, then set sw_frac_top=1.0. "}], "filename": "src/mom5/ocean_param/sources/ocean_shortwave_csiro.F90"}, {"namelist": "ocean_shortwave_gfdl_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be .true. to run with module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_chl", "description": " If .true. then read in climatological data of chlorophyll-a. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "optics_morel_antoine", "description": " For using the Morel and Antoine optics.  This was the default in MOM4.0 for use with chlorophyll data. This scheme is NOT available in MOM4p1 for use with the prognostic biology models, since it has been improved by the Manizza scheme. Default optics_morel_antoine=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "optics_manizza", "description": " For using the Manizza optics with chlorophyll data. Note that when running with a prognostic biology model, GFDL scientists use the Manizza optics. Default optics_manizza=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "enforce_sw_frac", "description": " To ensure the shortwave fraction is monotonically decreasing with depth. Applied only if optics_morel=.true. Default enforce_sw_frac=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "override_f_vis", "description": " To fix the fraction of incoming shortwave assigned to the visible at 0.57. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sw_morel_fixed_depths", "description": " To compute penetration assuming fixed depths via Grd%zw(k) depths. This is strictly incorrect when have undulating free surface and/or generatlized vertical coordinates.  This option is here for purposes of legacy, as this was done in MOM4.0 versions. The default is sw_morel_fixed_depths=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "optics_for_uniform_chl", "description": " To set the coefficients for optical model assuming the chlorophyll has a uniform distribution. Default optics_for_uniform_chl=.false. "}, {"default": "0.08", "units": "mg/m^3", "type_": "real", "name": "chl_default", "description": " Default concentration chl_default=0.08 roughly yields Jerlov Type 1A optics. "}, {"default": "1e6", "units": "meter", "type_": "real", "name": "zmax_pen", "description": " Maximum depth of penetration of shortwave radiation. Below this depth, shortwave penetration is exponentially small and so is ignored.  This option formerly was useful, since computation of exponentials expensive.  But with more modern computers, exponentials are cheap, so the default has been changed from 200 to 1e6, making this option irrelevant. But the option remains both for legacy purposes, and for those computers where exponentials are not cheap. Default zmax_pen=1e6. "}, {"default": "0.0", "units": null, "type_": "real", "name": "sw_frac_top", "description": " The fraction of shortwave radiation that should be incorporated into the sw_source array at k=1.  The generic treatment in MOM is to assume that shortwave radiation is already contained inside the T_prog(index_temp)%stf field. Hence, to avoid double counting, sw_frac(k=0)=sw_frac_top should=0.0. If one removes shortwave from stf, then set sw_frac_top=1.0. "}], "filename": "src/mom5/ocean_param/sources/ocean_shortwave_gfdl.F90"}, {"namelist": "ocean_shortwave_jerlov_nml", "items": [{"default": "1.", "units": null, "type_": "real", "name": "f_vis_in", "description": " F_vis is the amount of light in the shortwave versus the long wave. F_vis=0.54 on sunny days and F_vis=0.60 on cloudy days. With override_f_vis  = .true. F_vis is defined from f_vis_in. We believe, that this effect is in the first exponential in Paulson and Simpson (1977). The default is f_vis_in=1., instead of .57 but it is still possible to define this quantity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "enforce_sw_frac", "description": " To ensure the shortwave fraction is monotonically decreasing with depth. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "override_f_vis", "description": " With override_f_vis  = .true. F_vis is defined from f_vis_in, otherwise it is the shortwave versus the long wave amount of light. The default is .true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "override_coeff", "description": " With override_coeff  = .true. rpart_in, coef1_in, coef2_in specify the parameters for the double exponential. The default is .false.. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "sw_pen_fixed_depths", "description": " To compute penetration assuming fixed depths via Grd%zw(k) depths. This is strictly incorrect when have undulating free surface or generatlized vertical coordinates.  This option is here for purposes of legacy, as this was done in MOM4.0 versions. It saves some compute time if the surface elevation is small compared with the upper cells' thickness. The default is .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "jerlov_1", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "jerlov_2", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "jerlov_3", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "jerlov_1a", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "jerlov_1b", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "baltic_optics", "description": null}, {"default": "0.58", "units": null, "type_": "real", "name": "rpart_in", "description": " rpart_in = (0..1) "}, {"default": "0.35", "units": "meter", "type_": "real", "name": "coef1_in", "description": " "}, {"default": "23.", "units": "meter", "type_": "real", "name": "coef2_in", "description": " "}, {"default": "120.0", "units": "meter", "type_": "real", "name": "zmax_pen", "description": " Maximum depth of penetration of shortwave radiation. Below this depth, shortwave penetration is exponentially small and so is ignored. "}, {"default": "0.0", "units": null, "type_": "real", "name": "sw_frac_top", "description": " The fraction of shortwave radiation that should be incorporated into the sw_source array at k=1.  The generic treatment in MOM is to assume that shortwave radiation is already contained inside the T_prog(index_temp)%stf field. Hence, to avoid double counting, sw_frac(k=0)=sw_frac_top should=0.0. If one removes shortwave from stf, then set sw_frac_top=1.0. "}], "filename": "src/mom5/ocean_param/sources/ocean_shortwave_jerlov.F90"}, {"namelist": "ocean_sponges_eta_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}], "filename": "src/mom5/ocean_param/sources/ocean_sponges_eta.F90"}, {"namelist": "ocean_sponges_tracer_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "damp_coeff_3d", "description": " For case when damping coefficients are full 3d field of values. Default damp_coeff_3d=.false., which means damping coeffs are 2d horizontal array. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}], "filename": "src/mom5/ocean_param/sources/ocean_sponges_tracer.F90"}, {"namelist": "ocean_sponges_velocity_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "damp_coeff_3d", "description": " For case when damping coefficients are full 3d field of values. Default damp_coeff_3d=.false., which means damping coeffs are 2d horizontal array. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " For using this module.  Default use_this_module=.false. "}], "filename": "src/mom5/ocean_param/sources/ocean_sponges_velocity.F90"}, {"namelist": "ocean_xlandinsert_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose initialization information. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Needs to be true in order to use this scheme. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}], "filename": "src/mom5/ocean_param/sources/ocean_xlandinsert.F90"}, {"namelist": "ocean_xlandmix_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose initialization information. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Needs to be true in order to use this scheme. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "xlandmix_kmt", "description": " To allow xlandmixing to occur at k=kmt cell. Default is xlandmix_kmt=.false. "}], "filename": "src/mom5/ocean_param/sources/ocean_xlandmix.F90"}]}, {"directory": "src/mom5/ocean_param/vertical", "namelists": [{"namelist": "ocean_convect_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "convect_ncon", "description": " If true, will use the old NCON convection scheme from Cox. Retained only for legacy purposes to reproduce very old results. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "convect_full_scalar", "description": " If true, will use the full convection scheme as implemented at GFDL for scalar machines. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "convect_full_vector", "description": " If true, will use the full convection scheme as optimized for vector machines by russell.fiedler@csiro.au. "}, {"default": "7", "units": null, "type_": "integer", "name": "ncon", "description": " Number of passes through the NCON-scheme. "}], "filename": "src/mom5/ocean_param/vertical/ocean_convect.F90"}, {"namelist": "ocean_form_drag_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_form_drag_aiki", "description": " For using the Aiki form drag approach. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_aiki_bottom_layer", "description": " For implementing the Aiki form drag just in a selected number of bottom layers.  Will still insist that the scheme conserves momentum, as a form drag scheme should do. Default form_drag_aiki_bottom_layer=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_aiki_scale_by_gradH", "description": " For scaling the coefficient used by the form drag scheme with the bottom slope. "}, {"default": "0.05", "units": null, "type_": "real", "name": "form_drag_aiki_gradH_max", "description": " For scaling setting the maximum of the bottom slope for use with scaling the form drag coefficient. Default form_drag_aiki_gradH_max=.05 "}, {"default": "1.0", "units": null, "type_": "real", "name": "form_drag_aiki_gradH_power", "description": " For scaling the coefficient used by the form drag scheme with the bottom slope raised to the power \"form_drag_aiki_gradH_power\". "}, {"default": "3", "units": null, "type_": "integer", "name": "form_drag_aiki_bottom_klevels", "description": " Number of klevels above the bottom that we choose to close the Aiki form drag scheme.  Default form_drag_aiki_bottom_klevels=3. This should ideally be less than the minimum number of klevels in the model. "}, {"default": "0.3", "units": "dimensionless", "type_": "real", "name": "cprime_aiki", "description": " Dimensionless parameters from the Aiki etal scheme. Default cprime_aiki=0.3. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_form_drag_gbatch", "description": " For using the Greatbatch form drag approach, which places the contributions from \"GM\" into the momentum equation.  use_form_drag_gbatch, is the traditional transformed Eulerian mean approach as per Greatbatch and Lamb (1990) and Greatbatch (1998). In this approach, we modify visc_cbu so that the the \"GM-effects\" occur through vertical viscosity.  Since thise scheme is experimental, it is not recommended for general use, so we set default use_form_drag_gbatch=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_surf_layer", "description": " Logical to enable the use of a diabatic layer over which the eddy-induce velocity is assumed to be constant with depth. Default form_drag_gbatch_surf_layer=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_alpha_f2", "description": " For use of a vertical viscosity with the form_drag_gbatch that is equal to visc = form_drag_gbatch_alpha * f^2.  This form of the vertical viscosity is used by Ferreira and Marshall, 2006. Default form_drag_gbatch_alpha_f2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_f2overN2", "description": " To compute vertical viscosity according to visc=kappa*(f/N)**2 with kappa=gm-diffusivity, f=Coriolis, and N=buoyancy frequency. This is the form suggested by Greatbatch and Lamb (1990). Default form_drag_gbatch_f2overN2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_f2overNb2", "description": " To compute vertical viscosity according to visc=kappa*(f/Nb)**2 with kappa=gm-diffusivity, f=Coriolis, and Nb=buoyancy frequency just below the diabatic mixed layer. This is the form suggested by Danabasoglu and Marshall (2007). Default form_drag_gbatch_f2overNb2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_f2overNo2", "description": " To compute vertical viscosity according to visc=kappa*(f/No)**2 with kappa=gm-diffusivity, f=Coriolis, and No=constant buoyancy frequency set via namelist. Default form_drag_gbatch_f2overNo2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_gbatch_smooth_N2", "description": " For vertically smoothing the squared buoyancy frequency for use in computing the vertical viscosity in the form drag approach. Default form_drag_gbatch_smooth_N2=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "form_drag_aiki_scale_by_gm", "description": " Compute a dimensionless scale function proportional to the GM-diffusivity, for use with the Aiki etal form drag scheme. Default form_drag_aiki_scale_by_gm=.false. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": " Number of 1-2-1 passes for vertically smoothing the squared buoyancy frequency. Default num_121_passes=1. "}, {"default": "3", "units": null, "type_": "integer", "name": "ksurf_blayer_min", "description": " Minimum number of vertical grid points in the surface turbulent boundary layer for use with form_drag_gbatch_surf_layer=.true. Default ksurf_blayer_min=3. "}, {"default": "3e8", "units": "m^2*sec", "type_": "real", "name": "form_drag_gbatch_alpha", "description": " For use of a vertical viscosity with the form_drag_gbatch that is equal to visc = form_drag_gbatch_alpha * f^2. Default form_drag_gbatch_alpha=3e8 "}, {"default": "5e-3", "units": "sec^-1", "type_": "real", "name": "form_drag_gbatch_No", "description": " To compute vertical viscosity according to visc=kappa*(f/No)**2 with kappa=gm-diffusivity, f=Coriolis, and No=constant buoyancy frequency.  Default form_drag_gbatch_No=5e-3 "}, {"default": "1.0", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_form_drag_max", "description": " Maximum vertical viscosity used for the form drag contribution to vertical friction from the Greatbatch TEM approach. Default visc_cbu_form_drag_max=1m^2/sec. "}, {"default": "1.0", "units": "m/sec", "type_": "real", "name": "vel_form_drag_max", "description": " For diagnostic purpuses, maximum form drag eddy induced velocity. Default vel_form_drag_max=1m/sec. "}, {"default": "1e-10", "units": "1/sec", "type_": "real", "name": "N_squared_min", "description": " Minimum sequared buoyancy frequency (N^2) for use in computing the vertical viscosity from the Greatbatch form drag scheme. Default N_squared_min=1e-10. "}, {"default": "600.0", "units": null, "type_": "real", "name": "agm_form_drag", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose initialization information. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Needs to be true in order to use this scheme. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging. "}], "filename": "src/mom5/ocean_param/vertical/ocean_form_drag.F90"}, {"namelist": "ocean_vert_chen_nml", "items": [{"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_limit", "description": " Enhanced vertical viscosity due to shear instability "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_limit", "description": " Enhanced vertical diffusivity due to shear instability "}, {"default": "0.1", "units": null, "type_": "real", "name": "visc_con_limit", "description": null}, {"default": "0.1", "units": null, "type_": "real", "name": "diff_con_limit", "description": null}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_iw", "description": " Background vertical viscosity "}, {"default": "0.1e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_iw", "description": " Background vertical diffusivity.  Note that if using Bryan-Lewis as a background diffusivity, then should set diff_cbt_iw=0.0. "}, {"default": "0.4", "units": "", "type_": "real", "name": "bulk_tm", "description": " Bulk turblence parameter m_0 "}, {"default": "0.18", "units": "", "type_": "real", "name": "bulk_tn", "description": " Bulk turblence parameter n_0 "}, {"default": "100.", "units": "m/sec", "type_": "real", "name": "hbl_growth_max", "description": " Maximum growth rate of kraus mixed layer "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging.  Default debug_this_module=.false. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_chen.F90"}, {"namelist": "ocean_vert_const_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": "0.1e-4", "units": "m^2/sec", "type_": "real", "name": "kappa_h", "description": " The constant vertical diffusivity.  Used for cases when wanting a space-time independent diffusivity.  The \"h\" is historical and stands for \"heat\". "}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "kappa_m", "description": " The constant vertical viscosity.  Used for cases when wanting a space-time independent viscosity. "}, {"default": "1.0", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_limit", "description": " The largest allowable vertical diffusivity.  Of use for cases where vertically unstable columns are stabilized with a large vertical diffusivity. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_const.F90"}, {"namelist": "ocean_vert_gotm_nml", "items": [{"default": "'upwind'", "units": null, "type_": "character(len=10)", "name": "advect_gotm_method", "description": " For choosing how to advect the GOTM scalar fields tke and diss. Options are advect_gotm_method='upwind' (the default) advect_gotm_method='sweby' "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is .false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging.  Default is .false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_turbulence_gotm", "description": " For debugging.  If do_turbulence_gotm=.false., then will not invoke the GOTM scheme. Will only advect tke and diss using 3d advection scheme. Default is .true., so that will invoke GOTM scheme. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "do_advection_gotm", "description": " For debugging.  If do_advection_gotm=.false., then will not invoke the advection of tke and diss. Default is .true., so that will 3d advect tke and diss. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "map_velocity_gotm", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "map_production_gotm", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "correct_adv_errors", "description": null}, {"default": "1.0e-5", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_min", "description": " Background diffusivity.  Default is 1.0e-5. "}, {"default": "1.0e-5", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_min", "description": " Background viscosity.  Default is 1.0e-5. "}, {"default": "1.0", "units": "m", "type_": "real", "name": "z0s", "description": " Surface roughness length.  Default is 1m. "}, {"default": "0.002", "units": "m", "type_": "real", "name": "z0b", "description": " Bottom roughness length.  Default is .002m. "}, {"default": "1.0e-6", "units": "m^2/s^2", "type_": "real", "name": "min_tke", "description": " Minimum turbulent kinetic energy.  Default=1.0e-6. "}, {"default": "1.0e-10", "units": "m^2/s^3", "type_": "real", "name": "min_diss", "description": " Minimum energy dissipation.  Default=1.0e-10. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_gotm.F90"}, {"namelist": "ocean_vert_kpp_mom4p0_nml", "items": [{"default": "0.3", "units": "dimensionless", "type_": "real", "name": "Ricr", "description": " Critical bulk Richardson number.  Default from NCAR is 0.3, though this number has a large uncertainty and some find that 1.0 can be of use. "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_limit", "description": " Enhanced vertical viscosity due to shear instability "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_limit", "description": " Enhanced vertical diffusivity due to shear instability "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "visc_con_limit", "description": " Enhanced vertical viscosity in regions of convection "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "diff_con_limit", "description": " Enhanced vertical diffusivity in regions of convection "}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_iw", "description": " Background vertical viscosity "}, {"default": "0.1e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_iw", "description": " Background vertical diffusivity.  Note that if using Bryan-Lewis as a background diffusivity, then should set diff_cbt_iw=0.0. "}, {"default": "1.8", "units": "dimensionless", "type_": "real", "name": "concv", "description": " constant for pure convection (eqn. 23 of Large etal) "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Logical switch to enable kpp diffusion.  Default is false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "shear_instability", "description": " logical switch for shear instability mixing. Default shear_instability=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "double_diffusion", "description": " Logical switch for double-diffusive mixing. Default double_diffusion=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "wsfc_combine_runoff_calve", "description": " For computing wsfc as in the mom4p0d code, where we combine the runoff+calving into a single field called river. The alternative keeps the fields separate, as would be appropriate for a land model that separately tracks the tracer content in the calving and runoff. Default wsfc_combine_runoff_calve=.true., as this will recover the previous behaviour, to the bit. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "non_local_kpp", "description": " logical switch for enabling the non-local mixing aspect of kpp. Default is .true. as this is what the original KPP scheme suggests. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_blmc", "description": " Smooth boundary layer diffusitivies to remove grid scale noise. Such noise is apparent in the diagnosed mixed layer depth as well as the SST, especially when running coupled models where forcing has high temporal frequency. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "coastal_tidal_mix", "description": " For adding an extra vertical shear associated with tidal mixing. This method has found to be of use for mixing near shelves. "}, {"default": "3.0", "units": null, "type_": "real", "name": "sigma_tide", "description": " The sigma constant in the Munk-Anderson scheme Default sigma_tide=3.0 "}, {"default": "-0.25", "units": null, "type_": "real", "name": "p_tide", "description": " The p constant in the Munk-Anderson scheme Default p_tide=-0.25 "}, {"default": ".false.", "units": null, "type_": "logical", "name": "int_tidal_mix", "description": " For adding an internal tidal mixing over rough topography. This method has found to be of use for mixing in the rough topography in open ocean. Default int_tidal_mix=.false. "}, {"default": "300.0", "units": "metre", "type_": "real", "name": "int_tide_zeta1", "description": " Shallow depth for computation of internal tide. Default int_tide_zeta1=300.0 "}, {"default": "1800.0", "units": "metre", "type_": "real", "name": "int_tide_zeta2", "description": " Deeper depth for computation of internal tide. Default int_tide_zeta2=1800.0 "}, {"default": "100.0", "units": "metre", "type_": "real", "name": "int_tide_min_depth", "description": " Minimum depth for internal tide mixing to be computed. Default int_tide_min_depth=100.0 "}, {"default": "0.33333", "units": "dimensionless", "type_": "real", "name": "int_tide_q", "description": " Fraction of internal tide energy locally dissipated. Default int_tide_q=.33333 "}, {"default": "0.2", "units": "dimensionless", "type_": "real", "name": "int_tide_gamma", "description": " Dimensionless efficiency for converting energy dissipation to diffusivity. Default int_tide_gamma=0.2 "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_kpp_mom4p0.F90"}, {"namelist": "ocean_vert_kpp_mom4p1_nml", "items": [{"default": "0.3", "units": "dimensionless", "type_": "real", "name": "Ricr", "description": " Critical bulk Richardson number.  Default from NCAR is 0.3, though this number has a large uncertainty and some find that 1.0 can be of use. "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_limit", "description": " Enhanced vertical viscosity due to shear instability "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_limit", "description": " Enhanced vertical diffusivity due to shear instability "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "visc_con_limit", "description": " Enhanced vertical viscosity in regions of convection "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "diff_con_limit", "description": " Enhanced vertical diffusivity in regions of convection "}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_iw", "description": " Background vertical viscosity "}, {"default": "0.1e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_iw", "description": " Background vertical diffusivity.  Note that if using Bryan-Lewis as a background diffusivity, then should set diff_cbt_iw=0.0. "}, {"default": "1.8", "units": "dimensionless", "type_": "real", "name": "concv", "description": " constant for pure convection (eqn. 23 of Large etal) "}, {"default": "2", "units": null, "type_": "integer", "name": "kl_min", "description": " Lower loop index for finding new kbl. Needed for use with certain tests of OBC, where kl_min=1 needed, whereas default in original implementation has kl_min=2.  Default in MOM is kl_min=2. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "kbl_standard_method", "description": " For computing kbl as in the MOM4p0d code, which is taken from the original NCAR scheme.  If false, then will slightly modify the logic.  The modified logic has been found necessary when running with as few as two grid cells in the vertical. Default kbl_standard_method=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Logical switch to enable kpp diffusion.  Default is false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "shear_instability", "description": " logical switch for shear instability mixing. Default shear_instability=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "double_diffusion", "description": " Logical switch for double-diffusive mixing. Default double_diffusion=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "limit_ghats", "description": " Limits the non-local vertical tracer flux to the value of the tracer surface flux. Default limit_ghats=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "limit_with_hekman", "description": " Limiting the boundary layer depth with the Ekman depth may result in a shallow boundary layer. In this case the internal values of the vertical mixing and viscosity coefficients may be large. This results in unrealistically large non-local vertical mixing Default limit_with_hekman=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_large", "description": " Remove the shortwave radiation leaving the boundary layer to the ocean interior (hence, not absorbed in the boundary layer) from non-local vertical heat flux Default radiation_large=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_zero", "description": " Remove the all shortwave radiation from non-local vertical heat flux. Default radiation_zero=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_iow", "description": " Keep only the shortwave radiation absorbed between the surface and a certain level in non-local vertical heat flux through this level. Default radiation_iow=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "hbl_with_rit", "description": " The default method for determination of the boundary layer depth may fail if the water column is instable (negative Richardson number) below or above the layer that contains the diagnosed hbl. With hbl_with_rit=.true. the search for the boundary layer depth is continued downward in this case even if the bulk Richardson number exceeds the critical value. This removes a lot of noise from the boundary layer depth. Default hbl_with_rit=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_sbl_bottom_flux", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "wsfc_combine_runoff_calve", "description": " For computing wsfc as in the MOM4p0d code, where we combine the runoff+calving into a single field called river. The alternative keeps the fields separate, as would be appropriate for a land model that separately tracks the tracer content in the calving and runoff. Default wsfc_combine_runoff_calve=.true., as this will recover the previous behaviour, to the bit. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bvf_from_below", "description": " Use BV-freq. at the cell bottom instead of the cell top as in Danabasoglu et al. (2006). Default bvf_from_below=.false., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "variable_vtc", "description": " Make vtc dependent on BV-freq. as in Danabasoglu et al. (2006). Default variable_vtc=.false., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_max_shear", "description": " Use maximum shear instead of 4-point average (as in Danabasoglu et al. (2006)). Default use_max_shear=.false., as this will recover older behaviour. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "linear_hbl", "description": " Use linear interpolation to find the position of hbl. If set to false, then use the quadratic interpolation as in Danabasoglu et al. (2006). The quadratic approach generally yields a slightly deeper surface boundary layer. Default linear_hbl=.true., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "calc_visc_on_cgrid", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_ri_kmax_eq_kmu", "description": " When smoothing the Richardson number, we do so over a vertical column with max k-levels set by either kmt or kmu.  The proper approach is kmu, since we are smoothing riu.  But for backwards compatibility, we default to smooth_ri_kmax_eq_kmu=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "non_local_kpp", "description": " logical switch for enabling the non-local mixing aspect of kpp. Default is .true. as this is what the original KPP scheme suggests. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_blmc", "description": " Smooth boundary layer diffusitivies to remove grid scale noise. Such noise is apparent in the diagnosed mixed layer depth as well as the SST, especially when running coupled models where forcing has high temporal frequency. Default smooth_blmc=.false.  Warning: This smoother can cause some problems with ghat in regions of zero surface forcing.  To understand details, one needs the paper of Large et al. Vertical diffusion has the general form wx = K(x_z - ghats) In the surface layer a vertical scale function ws is estimated. We have K ~ ws and ghats ~1/ws. If wind stress is zero the vertical scale ws becomes zero too. Hence, ghats is very large (something finite, since it is divided by ws+epsln). Now it may happen, that the bouyancy flux becomes negative (~ -10-30). This enables the nonlocal scheme. Because the mixing coefficient in the surface boundary layer scales with ws the corresponding time tendency should be of the order (1/ws * ws = finite). However, if smooth_blmc is enabled, it may happen, that from neighbouring points with different mixing depth a finite value for the mixing coefficient leaks in. In this case the tracer time tendency from the nonlocal scheme becomes huge and the model fails.  The smoother destroys the consistency between ghats and diff_cbt. In most cases this should not matter, but the example shows, that sudden model failure is possible under otherwise stable and smooth conditions.  "}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " Logical switch for debugging. Default debug_this_module=.false. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_kpp_mom4p1.F90"}, {"namelist": "ocean_vert_kpp_test_nml", "items": [{"default": "0.3", "units": "dimensionless", "type_": "real", "name": "Ricr", "description": " Critical bulk Richardson number.  Default from NCAR is 0.3, though this number has a large uncertainty and some find that 1.0 can be of use. "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_limit", "description": " Enhanced vertical viscosity due to shear instability "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_limit", "description": " Enhanced vertical diffusivity due to shear instability "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "visc_con_limit", "description": " Enhanced vertical viscosity in regions of convection "}, {"default": "0.1", "units": "m^2/sec", "type_": "real", "name": "diff_con_limit", "description": " Enhanced vertical diffusivity in regions of convection "}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_iw", "description": " Background vertical viscosity "}, {"default": "0.1e-4", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_iw", "description": " Background vertical diffusivity.  Note that if using Bryan-Lewis as a background diffusivity, then should set diff_cbt_iw=0.0. "}, {"default": "1.8", "units": "dimensionless", "type_": "real", "name": "concv", "description": " constant for pure convection (eqn. 23 of Large etal) "}, {"default": "2", "units": null, "type_": "integer", "name": "kl_min", "description": " Lower loop index for finding new kbl. Needed for use with certain tests of OBC, where kl_min=1 needed, whereas default in original implementation has kl_min=2.  Default in MOM is kl_min=2. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "kbl_standard_method", "description": " For computing kbl as in the MOM4p0d code, which is taken from the original NCAR scheme.  If false, then will slightly modify the logic.  The modified logic has been found necessary when running with as few as two grid cells in the vertical. Default kbl_standard_method=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Logical switch to enable kpp diffusion.  Default is false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "shear_instability", "description": " logical switch for shear instability mixing. Default shear_instability=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "double_diffusion", "description": " Logical switch for double-diffusive mixing. Default double_diffusion=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "limit_ghats", "description": " Limits the non-local vertical tracer flux to the value of the tracer surface flux. Default limit_ghats=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "limit_with_hekman", "description": " Limiting the boundary layer depth with the Ekman depth may result in a shallow boundary layer. In this case the internal values of the vertical mixing and viscosity coefficients may be large. This results in unrealistically large non-local vertical mixing Default limit_with_hekman=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_large", "description": " Remove the shortwave radiation leaving the boundary layer to the ocean interior (hence, not absorbed in the boundary layer) from non-local vertical heat flux Default radiation_large=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_zero", "description": " Remove the all shortwave radiation from non-local vertical heat flux. Default radiation_zero=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "radiation_iow", "description": " Keep only the shortwave radiation absorbed between the surface and a certain level in non-local vertical heat flux through this level. Default radiation_iow=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "hbl_with_rit", "description": " The default method for determination of the boundary layer depth may fail if the water column is instable (negative Richardson number) below or above the layer that contains the diagnosed hbl. With hbl_with_rit=.true. the search for the boundary layer depth is continued downward in this case even if the bulk Richardson number exceeds the critical value. This removes a lot of noise from the boundary layer depth. Default hbl_with_rit=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_sbl_bottom_flux", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "wsfc_combine_runoff_calve", "description": " For computing wsfc as in the MOM4p0d code, where we combine the runoff+calving into a single field called river. The alternative keeps the fields separate, as would be appropriate for a land model that separately tracks the tracer content in the calving and runoff. Default wsfc_combine_runoff_calve=.true., as this will recover the previous behaviour, to the bit. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bvf_from_below", "description": " Use BV-freq. at the cell bottom instead of the cell top as in Danabasoglu et al. (2006). Default bvf_from_below=.false., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "variable_vtc", "description": " Make vtc dependent on BV-freq. as in Danabasoglu et al. (2006). Default variable_vtc=.false., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_max_shear", "description": " Use maximum shear instead of 4-point average (as in Danabasoglu et al. (2006)). Default use_max_shear=.false., as this will recover legacy behaviour. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "linear_hbl", "description": " Use linear interpolation to find the position of hbl. If set to false, then use the quadratic interpolation as in Danabasoglu et al. (2006). The quadratic approach generally yields a slightly deeper surface boundary layer. Default linear_hbl=.true., as this will recover older behaviour. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_ri_kmax_eq_kmu", "description": " When smoothing the Richardson number, we do so over a vertical column with max k-levels set by either kmt or kmu.  The proper approach is kmu, since we are smoothing riu.  But for backwards compatibility, we default to smooth_ri_kmax_eq_kmu=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "non_local_kpp", "description": " logical switch for enabling the non-local mixing aspect of kpp. Default is .true. as this is what the original KPP scheme suggests. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "smooth_blmc", "description": " Smooth boundary layer diffusitivies to remove grid scale noise. Such noise is apparent in the diagnosed mixed layer depth as well as the SST, especially when running coupled models where forcing has high temporal frequency. Default smooth_blmc=.false.  Warning: This smoother can cause some problems with ghat in regions of zero surface forcing.  To understand details, one needs the paper of Large et al. Vertical diffusion has the general form wx = K(x_z - ghats) In the surface layer a vertical scale function ws is estimated. We have K ~ ws and ghats ~1/ws. If wind stress is zero the vertical scale ws becomes zero too. Hence, ghats is very large (something finite, since it is divided by ws+epsln). Now it may happen, that the bouyancy flux becomes negative (~ -10-30). This enables the nonlocal scheme. Because the mixing coefficient in the surface boundary layer scales with ws the corresponding time tendency should be of the order (1/ws * ws = finite). However, if smooth_blmc is enabled, it may happen, that from neighbouring points with different mixing depth a finite value for the mixing coefficient leaks in. In this case the tracer time tendency from the nonlocal scheme becomes huge and the model fails.  The smoother destroys the consistency between ghats and diff_cbt. In most cases this should not matter, but the example shows, that sudden model failure is possible under otherwise stable and smooth conditions.  "}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " Logical switch for debugging. Default debug_this_module=.false. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_kpp_test.F90"}, {"namelist": "ocean_vert_mix_nml", "items": [{"default": "'const'", "units": null, "type_": "character(len=10)", "name": "vert_mix_scheme", "description": " To determine the vertical mixing scheme: \"const\", \"kpp\", \"kpp_mom4p0\",\"kpp_mom4p1\", \"chen\", \"pp\", or \"gotm\". "}, {"default": "1.0", "units": null, "type_": "real", "name": "aidif", "description": " aidif=1 for implicit in time solution of the vertical mixing equation. aidif=0 for explicit in time solution of the vertical mixing equation. semi-implicit method with 0 < aidif < 1 is not fully supported in MOM. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "vert_diff_back_via_max", "description": " If .true. then include a static background diffusivity via the max function, as used in mom4p0d.  The alternative is via simply adding the background to the diffusivity obtained via other approaches.  This option remains for legacy. Default is vert_diff_back_via_max=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "use_explicit_vert_diffuse", "description": " Must be true to use time-explicit vertical tracer diffusion. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bryan_lewis_diffusivity", "description": " If .true. then add a Bryan-Lewis background to the diffusivity.  This background is a time-independent function of depth.  This diffusivity is NOT used when have use_pp_vert_mix_coeff=.true. This scheme should NOT be used if HWF is used. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "bryan_lewis_lat_depend", "description": " If .true. then allow for Bryan-Lewis background to be different outside of a tropical band than inside the band. "}, {"default": "35.0", "units": null, "type_": "real", "name": "bryan_lewis_lat_transition", "description": " North/South latitude where transition from Bryan-Lewis values in the tropic to those in the higher latitudes. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "vert_visc_back", "description": " If .true. then include a static depth dependent vertical viscosity which is used only if running w/ constant vertical viscosity scheme. Standard application is when have a model with fine vertical resolution, yet no mixed layer scheme.  Wind stress must be spread deeper than the top cell, or the model may go unstable, or at the least it will produce spuriously large vertical shears. "}, {"default": "1e-2", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_back_max", "description": " For use in setting background vertical viscosity. "}, {"default": "1e-3", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_back_min", "description": " For use in setting background vertical viscosity. "}, {"default": "50.0", "units": "m", "type_": "real", "name": "visc_cbu_back_zmid", "description": " Mid-point of tanh function used to define background vertical viscosity. "}, {"default": "30.0", "units": "m", "type_": "real", "name": "visc_cbu_back_zwid", "description": " Width of tanh function used to define background vertical viscosity. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "diff_cbt_tanh", "description": " For enabling tanh background vertical diffusivity profile. Default diff_cbt_tanh=.false. "}, {"default": "1e-3", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_tanh_max", "description": " For use in setting background vertical diffusivity. Default diff_cbt_tanh_max=1e-3. "}, {"default": "2e-5", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_tanh_min", "description": " For use in setting background vertical diffusivity. Default diff_cbt_tanh_min=2e-5. "}, {"default": "150.0", "units": "m", "type_": "real", "name": "diff_cbt_tanh_zmid", "description": " Mid-point of tanh function used to define background vertical diffusivity. Default diff_cbt_tanh_zmid=150.0. "}, {"default": "30.0", "units": "m", "type_": "real", "name": "diff_cbt_tanh_zwid", "description": " Width of tanh function used to define background vertical diffusivity. Default diff_cbt_tanh_zwid=30.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_diff_cbt_table", "description": " If .true., then read in a table that specifies (i,j,ktop-->kbottom) and the diffusivity. This method is useful when aiming to mix vertically at points where do cross-land insertion or where may wish to enhance mixing at river mouths. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "linear_taper_diff_cbt_table", "description": " If .true., then linear taper the diff_cbt_table value from so that it gets smaller with depth. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "hwf_diffusivity", "description": " 3D background diffusivity which gets smaller in equatorial region. Based on the work of Henyey etal (1986). This scheme should NOT be used if Bryan-Lewis is used. Default hwf_diffusivity=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "hwf_diffusivity_3d", "description": " 3D background diffusivity which gets smaller in equatorial region. Based on the work of Henyey etal (1986). This form has not been used much at GFDL, with preference given to a simpler two-dimensional (depth independent) form assessed with the default hwf_diffusivity_3d=.false. "}, {"default": "2500.0e4", "units": "m", "type_": "real", "name": "hwf_depth_transition", "description": " Depth of transition for hwf scheme.  The HWF method actually has no depth dependence.  But we include the atan depth dependency from Bryan-Lewis, for those cases where we wish to replace Bryan-Lewis with the HWF scheme.  To get the usual Bryan-Lewis transition, set hwf_depth_transition=2500.0.  However, since we often use hwf in the presence of tide mixing, we do not wish to have any depth dependence, in which case the default is hwf_depth_transition=2500.0e4. "}, {"default": "2.e-6", "units": "m^2/sec", "type_": "real", "name": "hwf_min_diffusivity", "description": " Minimum diffusivity for the HWF scheme. Default hwf_min_diffusivity=2e-6. "}, {"default": "2.e-5", "units": "m^2/sec", "type_": "real", "name": "hwf_30_diffusivity", "description": " Diffusivity at 30deg latitude for the HWF scheme. Default hwf_30_diffusivity=2e-5. "}, {"default": "20.0", "units": "dimensionless", "type_": "real", "name": "hwf_N0_2Omega", "description": " Ratio of the typical Buoyancy frequency to twice the earth's rotation period. Default hwf_N0_2Omega=20.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "vmix_rescale_nonbouss", "description": " To rescale the vertical mixing coefficients by rho0/rho in order to bring the effects from vertical diffusion in a non-Boussinesq model more in line with that from a Boussinesq model. Default vmix_rescale_nonbouss=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "vmix_set_min_dissipation", "description": " To set a minimum dissipation rate.  This scheme will compute the dissipation from the full diffusivity.  If the resulting dissipation is smaller than a specified dissipation, then the diffusivity will be locally increased so that the min dissipation is maintained. Default vmix_set_min_dissipation=.false. "}, {"default": "1e-7", "units": "W/m^3", "type_": "real", "name": "vmix_min_diss_const", "description": " Minimum dissipation rate as a constant. Default vmix_min_diss_const=1e-7. "}, {"default": "6e-4", "units": "J/m^3", "type_": "real", "name": "vmix_min_diss_bvfreq_scale", "description": " Scaling use to set the minimum dissipation rate as determined by the local stratification. Default vmix_min_diss_bvfreq_scale=6e-4. "}, {"default": "0.2", "units": "dimensionless", "type_": "real", "name": "vmix_min_diss_flux_ri_max", "description": " Maximum flux Richardson number for computation of diffusivity from dissipation. Default vmix_min_diss_flux_ri_max=0.2. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_rho_N2", "description": null}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "verbose_init", "description": " For verbose writes during initialization. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "quebec_2009_10_bug", "description": null}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_mix.F90"}, {"namelist": "ocean_vert_pp_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " Must be true to use this module. Default is false. "}, {"default": "50.0e-4", "units": "m^2/sec", "type_": "real", "name": "fricmx", "description": " Maximum mixing "}, {"default": "10.0e-4", "units": "m^2/sec", "type_": "real", "name": "wndmix", "description": " Minimum viscosity at bottom of 1st level to simulate missing high frequency windstress components. "}, {"default": "1.0e-5", "units": "m^2/sec", "type_": "real", "name": "diff_cbt_back_pp", "description": " Space-time independent background vertical diffusivity thought to be that arising from internal waves. Note that if using Bryan-Lewis background diffusivity, then should set diff_cbt_back_pp=0.0. "}, {"default": "1.0e-4", "units": "m^2/sec", "type_": "real", "name": "visc_cbu_back_pp", "description": " Background vertical viscosity "}, {"default": "1.0e2", "units": null, "type_": "real", "name": "visc_cbu_limit", "description": null}, {"default": "1.0e2", "units": null, "type_": "real", "name": "diff_cbt_limit", "description": null}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_pp.F90"}, {"namelist": "ocean_vert_tidal_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_legacy_methods", "description": " To compute all mixing coefficients using legacy methods. There are good reasons to prefer the newer approaches, which motivates setting the default use_legacy_methods=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_wave_dissipation", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_drag_dissipation", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_leewave_dissipation", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_roughness", "description": " If .true. then read in bottom roughness amplitude h, where roughness_length = kappa*h^2, with kappa a representative roughness wavelength and h a representative topographic amplitude.  This information is used for the Simmons etal wave dissipation parameterization. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_wave_dissipation", "description": " If .true. then read in wave dissipation computed from Jayne and St.Laurent (2001) tide model (or another model). Default read_wave_dissipation=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_leewave_dissipation", "description": " If .true. then read in leewave dissipation from a file. Default read_leewave_dissipation=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "reading_roughness_amp", "description": " If .true., then the field in the roughness file is roughness_amp=h, where roughness_length=kappa*h^2. This information is used for the Simmons etal wave dissipation parameterization. Default reading_roughness_amp=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "reading_roughness_length", "description": " If .true., then the field in the roughness file is roughness_length = kappa*h^2, with kappa a representative roughness wavelength and h a representative topographic amplitude.  This information is used for the Simmons etal wave dissipation parameterization. Default reading_roughness_length=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "read_tide_speed", "description": " If .true. then read in tidal speed (m/s) from a tidal model. This information is used for the computing the energy dissipation from tides. scheme. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "wave_diffusivity_monotonic", "description": " Enforce a monotonic decay of the wave dissipation diffusivity, with largest values near bottom and smaller as move to shallower water.  This behaviour is not guaranteed in general, since the division by the buoyancy frequency can give non-monotone diffusivities. Default wave_diffusivity_monotonic=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "tide_speed_data_on_t_grid", "description": " To set the input tide speed data on T-grid, set to true. Otherwise, set to false. Default tide_speed_data_on_t_grid=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "fixed_wave_dissipation", "description": " If .true. then fix the wave dissipation from that read in by the tide model, such as Jayne and St.Laurent (2001). This power dissipation will be employed for computing wave induced mixing. Default fixed_wave_dissipation=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "mixing_efficiency_n2depend", "description": " Allow for mixing efficiency to be a function of N^2/(N^2+Omega^2), which is close to unity except in regions where N is very small. Default mixing_efficiency_n2depend=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "drag_dissipation_efold", "description": " For setting an efolding whereby the drag dissipation diffusivity exponentially decreases as move upward in the water column. There are good reasons to set this logical to true, as the scheme can produce unreasonably large diffusivities far from the bottom, if there are tides in the deep ocean. Default drag_dissipation_efold=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_bvfreq_bottom", "description": " For smoothing the buoyancy frequency at the bottom. Default smooth_bvfreq_bottom=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "drag_mask_deep", "description": " For masking out the deep ocean regions for the drag dissipation scheme.  This scheme is meant to apply only in shallow shelves, so it is physically relevant to mask it out.  We apply a mask as determined by the ratio of the frictional tide depth scale and the total ocean depth. Default drag_mask_deep=.true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_rho_N2", "description": " For smoothing the rho_N2 field via a 1-2-1 filter in vertical.  This is useful to produce smoother diffusivities. Default is smooth_rho_N2=.true. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_121_passes", "description": " Number of passes of 1-2-1 filter in vertical for smoothing the rho_N2 field. Default num_121_passes=1. "}, {"default": "0.1", "units": null, "type_": "real", "name": "drag_mask_deep_ratio", "description": " For determining the drag dissipation mask. The mask = 0 in regions where tide_depth/total_depth < drag_mask_deep_ratio Default drag_mask_deep_ratio=0.1 "}, {"default": "85e3", "units": "m", "type_": "real", "name": "roughness_scale", "description": " Scale for the roughness that characterizes the roughness affecting the tidal dissipation process. Used for setting roughness_length via roughness_length = kappa*h^2, with kappa = 2pi/(roughness_scale) and h=topography amplitude. Default roughness_scale=1e4 as in Jayne and St. Laurent (2001) "}, {"default": "25.0", "units": "m", "type_": "real", "name": "default_roughness_length", "description": " Default value for kappa*h^2 = roughness length for use in the absence of a roughness length dataset. MOM default is default_roughness_length=25.0m. "}, {"default": ".01", "units": "m/s", "type_": "real", "name": "default_tide_speed", "description": " Default value for tidal speed for use in the absence of a value from a tidal model. "}, {"default": "-1000.0", "units": "m", "type_": "real", "name": "shelf_depth_cutoff", "description": " For use in defining a mask for the Simmons scheme, with depths shallower than shelf_depth_cutoff removed from the scheme. shelf_depth_cutoff=1000m in Simmons etal. Default shelf_depth_cutoff=-1000m so there is no cutoff. "}, {"default": "500.0", "units": "m", "type_": "real", "name": "decay_scale", "description": " In the Simmons etal vertical profile function, the exponential decay scale is determined by this parameter.  Default = 500m as in Simmons etal (2004).  This vertical profile determines how to deposit the internal wave energy within a vertical column. "}, {"default": "0.33333", "units": "dimensionless", "type_": "real", "name": "tidal_diss_efficiency", "description": " Fraction of barotropic tidal energy that is dissipated locally, as opposed to that which propagates away.  Default=1/3 as in Simmons etal (2004). "}, {"default": "0.2", "units": "dimensionless", "type_": "real", "name": "mixing_efficiency", "description": " Fraction of energy that is dissipated which is converted into dianeutral diffusion of tracer.  Default=0.2 based on Osborn (1980). "}, {"default": "0.25", "units": "dimensionless", "type_": "real", "name": "munk_anderson_p", "description": " The p constant in the Munk-Anderson scheme employed by Lee etal. This parameter is minus the \"p_tide\" parameter in the KPP schemes. Default munk_anderson_p=0.25 "}, {"default": "3.0", "units": "dimensionless", "type_": "real", "name": "munk_anderson_sigma", "description": " The sigma constant in the Munk-Anderson scheme employed by Lee etal. This parameter is called \"sigma_tide\" in the KPP schemes. Default munk_anderson_sigma=3.0 "}, {"default": "2.4e-3", "units": "dimensionless", "type_": "real", "name": "bottom_drag_cd", "description": " Bottom drag coefficient from Lee etal. Default bottom_drag_cd=2.4e-3 "}, {"default": "0.1e-4", "units": "m^2/s", "type_": "real", "name": "background_diffusivity", "description": " Background vertical diffusivity not accounted for by the tidal schemes nor any other scheme such as KPP.  Default=0.1e-4. "}, {"default": "0.1e-4", "units": "m^2/s", "type_": "real", "name": "background_viscosity", "description": " Background vertical viscosity not accounted for by the tidal schemes nor any other scheme such as KPP.  Default=0.1e-4. "}, {"default": "5.0e-3", "units": "m^2/s", "type_": "real", "name": "max_wave_diffusivity", "description": " Maximum tracer diffusivity deduced from the wave dissipation scheme from Simmons etal. Default = 5.e-3 m^2/sec. "}, {"default": "5.0e-3", "units": "m^2/s", "type_": "real", "name": "max_drag_diffusivity", "description": " Maximum tracer diffusivity deduced from the drag dissipation scheme from Lee etal. Default = 5.e-3 m^2/sec. "}, {"default": "1.e-10", "units": "kg/m^3", "type_": "real", "name": "drhodz_min", "description": " Minimum absolute value for the drhodz used to compute N^2 and rhoN2. This value is needed in order to regularize the diffusivity computed from the tide mixing schemes. Default is drhodz_min=1e-10, which is much smaller than the (N^2)min = 10^-8 sec^-2 used by Simmons etal. There is some sensitivity to the choice of drhodz_min, with larger values leading to reduced deep diffusivities, due to the N^-2 dependence in the diffusivity calculation. "}, {"default": "5.e-3", "units": "m/s", "type_": "real", "name": "speed_min", "description": " For the drag scheme, we set the diffusivity as well as the Richardson number to zero if the tide speed is less than speed_min.  This serves two purposes: 1/ to reduce overflows in some of the diagnostics; 2/ to set the drag induced diffusivity to zero in regions where the tide speed is small. Default speed_min=5e-3m/s. "}, {"default": "0.1", "units": "W/m2", "type_": "real", "name": "wave_energy_flux_max", "description": " The maximum mechanical energy from internal tides that is provided for mixing.  Default wave_energy_flux_max=0.1Watt/m^2. "}, {"default": "43200.", "units": "s", "type_": "real", "name": "drag_dissipation_tide_period", "description": " Characteristic tide period for use in computing efolding depth for the tide drag scheme.  Default = 12*60*60 = 12hours for semi-diurnal tide. "}, {"default": "0.2", "units": "m/sec", "type_": "real", "name": "vel_micom_smooth", "description": " Velocity scale that is used for computing the MICOM Laplacian mixing coefficient used in the Laplacian smoothing of diffusivities. Default vel_micom_smooth=0.2. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "drag_dissipation_use_cdbot", "description": " For using the cdbot_array computed from ocean_bbc.F90 module. Default drag_dissipation_use_cdbot=.false., as this is consistent with earlier simulations. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_tidal.F90"}, {"namelist": "ocean_vert_util_nml", "items": [{"default": ".true.", "units": null, "type_": "logical", "name": "smooth_n2", "description": " For vertical smoothing the N2 calculation for Richardson number. Default smooth_n2 = .true. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "smooth_ri_number", "description": " For vertical smoothing richardson number. Default smooth_ri_number = .true. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_n2_smooth", "description": " For vertical smoothing N2 for Richardson number. Default num_n2_smooth = 1. "}, {"default": "1", "units": null, "type_": "integer", "name": "num_ri_smooth", "description": " For vertical smoothing richardson number. Default num_ri_smooth = 1. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging purposes. "}], "filename": "src/mom5/ocean_param/vertical/ocean_vert_util.F90"}]}, {"directory": "src/mom5/ocean_tracers", "namelists": [{"namelist": "ocean_frazil_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "use_this_module", "description": " If true, then compute frazil heating. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging this module "}, {"default": ".false.", "units": null, "type_": "logical", "name": "freezing_temp_simple", "description": " To use the simplified freezing point temperature of seawater, as used in MOM4.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "freezing_temp_preteos10", "description": null}, {"default": ".false.", "units": null, "type_": "logical", "name": "freezing_temp_teos10", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "air_saturated_water", "description": null}, {"default": ".true.", "units": null, "type_": "logical", "name": "frazil_only_in_surface", "description": " For typical case where compute frazil heating only in the surface grid cell.  Will assume the gauge pressure is zero in this case when computing freezing temperature. "}, {"default": "1.0", "units": "dimensionless", "type_": "real", "name": "frazil_factor", "description": " This factor accounts for possibly different time stepping used in the sea ice model relative to the ocean model.  If sea-ice and ocean use same time stepping schemes, then frazil_factor=1.0. If sea-ice uses a twolevel scheme and ocean a threelevel leap-frog, then frazil_factor=0.5. Default is 1.0 since the GFDL sea ice model SIS uses  a two-level time stepping scheme and MOM defaults to a staggered two-level scheme. "}], "filename": "src/mom5/ocean_tracers/ocean_frazil.F90"}, {"namelist": "ocean_passive_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging the module. "}, {"default": "'patch'", "units": null, "type_": "character(len=32)", "name": "common_init_condition", "description": " Default for the tracer initial conditions.  Options are the following: common_init_condition='level' common_init_condition='wall' common_init_condition='patch' common_init_condition='patch_'klevel, with \"klevel\" an integer for the k-level that will place the patch. common_init_condition='exponential' common_init_condition='shelfbowl' common_init_condition='rho_surface' common_init_condition='temp_sq_init' common_init_condition='salt_sq_init' Default=common_init_condition='patch' "}, {"default": "1.0", "units": null, "type_": "real", "name": "layer_value", "description": " Value of tracer concentration within the layer. Default=1.0. "}, {"default": "100.0", "units": null, "type_": "real", "name": "layer_ztop", "description": " Depth at the top of the tracer layer. "}, {"default": "200.0", "units": null, "type_": "real", "name": "layer_zbot", "description": " Depth at the bottom of the tracer layer. "}, {"default": "1.0", "units": null, "type_": "real", "name": "wall_value", "description": " Value of tracer concentration within the wall. Default=1.0. "}, {"default": "0.33333", "units": null, "type_": "real", "name": "wall_ratio_south", "description": " Ratio of the full j-range, northward of which we place the wall. "}, {"default": "0.66666", "units": null, "type_": "real", "name": "wall_ratio_north", "description": " Ratio of the full j-range, southward of which we place the wall. "}, {"default": "1.0", "units": null, "type_": "real", "name": "patch_value", "description": " Value of the tracer concentration within a patch. Default=1.0. "}, {"default": "0.0", "units": null, "type_": "real", "name": "patch_ztop", "description": " Depth at the top of the tracer patch. "}, {"default": "200.0", "units": null, "type_": "real", "name": "patch_zbot", "description": " Depth at the bottom of the tracer patch. "}, {"default": "0.33333", "units": null, "type_": "real", "name": "patch_ratio1", "description": " For setting position of tracer patch. "}, {"default": "0.66666", "units": null, "type_": "real", "name": "patch_ratio2", "description": " For setting position of tracer patch. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "patch_init_klevel_gaussian", "description": " To initialize on the klevel with a gaussian region. Default=patch_init_klevel_gaussian=.false. "}, {"default": "70.0", "units": null, "type_": "real", "name": "shelfbowl_north", "description": null}, {"default": "1.0", "units": null, "type_": "real", "name": "shelf_value", "description": null}, {"default": "1000.0", "units": "metre", "type_": "real", "name": "efold_depth", "description": " The efolding depth used for exponential tracer profile. Default=1000.0. "}, {"default": "1.0", "units": "dimensionless", "type_": "real", "name": "exponential_value", "description": " The tracer value at zero depth when choosing the exponential profile. Default=1.0. "}], "filename": "src/mom5/ocean_tracers/ocean_passive.F90"}, {"namelist": "ocean_tempsalt_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "reinit_ts_with_ideal", "description": " For setting up an ideal temperature and salinity profile that is generated in the model. This profile can be generated after the model has already been running, hence the name \"reinit\" for \"reinitialize.\" "}, {"default": "1000.0", "units": "metre", "type_": "real", "name": "reinit_ts_with_ideal_efold", "description": " For setting efolding of reinitialized temp and salinity profile. Default reinit_ts_with_ideal_efold=1000. "}, {"default": "10.0", "units": "C", "type_": "real", "name": "reinit_ts_with_ideal_tvalue", "description": " For setting the reinitialized temperature value using the ideal profile. Default reinit_ts_with_ideal_tvalue = 10.0 "}, {"default": "30.0", "units": "psu", "type_": "real", "name": "reinit_ts_with_ideal_svalue", "description": " For setting the reinitialized temperature value using the ideal profile. Default reinit_ts_with_ideal_svalue = 30.0 "}, {"default": "-5.0", "units": "deg C", "type_": "real", "name": "t_min", "description": " Minimum potential/conservative temperature below which we gracefully bring down the model. "}, {"default": "40.0", "units": "deg C", "type_": "real", "name": "t_max", "description": " Maximum potential/conservative temperature above which we gracefully bring down the model. "}, {"default": "0.0", "units": "ppt", "type_": "real", "name": "s_min", "description": " Minimum salinity below which we gracefully bring down the model. "}, {"default": "70.0", "units": "ppt", "type_": "real", "name": "s_max", "description": " Maximum salinity below which we gracefully bring down the model. "}, {"default": "-2.0", "units": "deg C", "type_": "real", "name": "t_min_limit", "description": " Minimum potential/conservative temperature below which will employ upwind advection instead of quicker, and horizontal diffusion instead of neutral physics. "}, {"default": "32.0", "units": "deg C", "type_": "real", "name": "t_max_limit", "description": " Maximum potential/conservative temperature above which will employ upwind advection instead of quicker, and horizontal diffusion instead of neutral physics. "}, {"default": "1.0", "units": "psu", "type_": "real", "name": "s_min_limit", "description": " Minimum salinity below which will employ upwind advection instead of quicker, and horizontal diffusion instead of neutral physics. "}, {"default": "42.0", "units": "psu", "type_": "real", "name": "s_max_limit", "description": " Maximum salinity below which will employ upwind advection instead of quicker, and horizontal diffusion instead of neutral physics. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging the module. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "pottemp_2nd_iteration", "description": " For taking extra iteration in computation of potential temperature from conservative temperature and salinity. Default is true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "pottemp_equal_contemp", "description": " For certain idealized cases where the difference between potential temperature and conservative temperature is irrelevant. Default=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "teos10", "description": " For choosing whether to use the TEOS-10 equation of state. This usage requires conservative temperature as the temperature variable, and two salinity variables: Preformed Salinity and Absolute Salinity anomaly. Default teos10=.false. "}, {"default": "'conservative_temp'", "units": null, "type_": "character(len=32)", "name": "temperature_variable", "description": " For choosing the temperature variable used in the model. Choices are 'conservative_temp' and 'potential_temp'. Since conservative temperature is more accurate, it is the default. "}], "filename": "src/mom5/ocean_tracers/ocean_tempsalt.F90"}, {"namelist": "ocean_tracer_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "zero_tendency", "description": " If true, then will freeze the tracer fields. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tracer_source", "description": " To remove the T_prog%source contribution to tracer evolution. For debugging purposes.  Default zero_tracer_source=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging the tracer module "}, {"default": ".true.", "units": null, "type_": "logical", "name": "tmask_limit_ts_same", "description": " tmask_limit is derived separately for the tracers.  However, it may be appropriate to have the mask be the same for temp and salinity, in which case the neutral physics fluxes are self-consistent.  But for some cases, such as when running with linear eos, may not wish to have the temp and salinity coupled when computing the mask. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "remap_depth_to_s_init", "description": " For remapping initial tracer distributions, generally determined according to depth vertical coordinates using the mom preprocessing schemes, onto s-coordinates.  This method is of use for initializing terrain following coordinate simulations with mom. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "inflow_nboundary", "description": " For adding an inflow transport from the northern boundary which brings in temp and salinity according to inflow data files. Default is inflow_nboundary=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "interpolate_tprog_to_pbott", "description": " To linear interpolate the initial conditions for prognostic tracers to the partial bottom cells.  Default interpolate_tprog_to_pbott=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "interpolate_tdiag_to_pbott", "description": " To linear interpolate the initial conditions for diagnostic tracers to the partial bottom cells.  Default interpolate_tdiag_to_pbott=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "limit_age_tracer", "description": " Limit the values of age tracer to be less than total run time and greater than zero. Default limit_age_tracer=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "frazil_heating_before_vphysics", "description": " For computing frazil heating before the implicit vertical physics (which includes boundary fluxes), and before vertical convection. This is the order that CM2.0 and CM2.1 performed their calculations of frazil.  It is arguable that one should NOT do frazil until the end of a time step, after vertical physics and after surface boundary fluxes. Default frazil_heating_before_vphysics=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "frazil_heating_after_vphysics", "description": " For computing frazil heating after the implicit vertical physics (which includes boundary fluxes), and after vertical convection. This is the recommended method. Default frazil_heating_after_vphysics=.false. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "compute_tmask_limit_on", "description": " For updating the tmaks_limit array. This calculation is recommended for the following physics and advection schemes: 1/ quicker advection 2/ neutral physics 3/ submesoscale closure. The default is compute_tmask_limit_on=.true., but if none of the above schemes is used, then some time savings can be realized by setting compute_tmask_limit_on=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "use_tempsalt_check_range", "description": " To call a check to see that temperature and salinity are within their pre-selected range. Default use_tempsalt_check_range=.false. since this check may incur some cost that users should be aware of. "}, {"default": "0.0", "units": "years", "type_": "real", "name": "age_tracer_max_init", "description": " Initial maximum age tracer. This nml provides the ability to start an integration with an age tracer that is not initialized to zero, say if we took an age tracer from another spin-up. Default age_tracer_max_init=0.0. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "ocean_tpm_debug", "description": " For debugging ocean tracer package manager. "}], "filename": "src/mom5/ocean_tracers/ocean_tracer.F90"}, {"namelist": "ocean_tracer_advect_nml", "items": [{"default": ".false.", "units": null, "type_": "logical", "name": "read_basin_mask", "description": " For reading in a mask that selects regions of the domain for performing gyre and overturning diagnostics. The basin-mask convention used at GFDL has Southern=1.0,Atlantic=2.0,Pacific=3.0,Arctic=4.0,Indian=5.0 Default read_basin_mask=.false., whereby basin_mask is set to tmask(k=1). "}, {"default": ".false.", "units": null, "type_": "logical", "name": "limit_with_upwind", "description": " If true, will compute tracer fluxes entering a cell using upwind if the tracer value is outside a specified range. Implemented only for quick at this time. This is an ad hoc and incomplete attempt to maintain monotonicity with the quicker scheme. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "debug_this_module", "description": " For debugging "}, {"default": ".false.", "units": null, "type_": "logical", "name": "advect_sweby_all", "description": " For running all tracers with sweby, thereby utilizing a bitwise same routine that reorganizes loops and can be faster for certain configurations. Default advect_sweby_all=.false. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tracer_advect_horz", "description": " For debugging.  Set to .true. to turn off horizontal advection. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "zero_tracer_advect_vert", "description": " For debugging.  Set to .true. to turn off vertical advection. "}, {"default": ".true.", "units": null, "type_": "logical", "name": "write_a_restart", "description": " Set true to write a restart.  False setting only for rare cases where wish to benchmark model without measuring the cost of writing restarts and associated chksums. Default is write_a_restart=.true. "}, {"default": ".false.", "units": null, "type_": "logical", "name": "psom_limit_prather", "description": " For running with the original Prather limiter for the PSOM scheme. The limiter is positive definite, but not monotonic.  This limiter is NOT recommended for most applications.  The default is psom_limit_prather=.false., since we prefer to use the limiter from Merryfield and Holloway (2003). "}, {"default": ".false.", "units": null, "type_": "logical", "name": "async_domain_update", "description": null}], "filename": "src/mom5/ocean_tracers/ocean_tracer_advect.F90"}]}, {"directory": "src/mom5/ocean_wave", "namelists": [{"namelist": "ocean_wave_nml", "items": [{"default": "-10.", "units": null, "type_": "real", "name": "wavedamp", "description": null}, {"default": ".TRUE.", "units": null, "type_": "logical", "name": "damp_where_ice", "description": null}, {"default": ".TRUE.", "units": null, "type_": "logical", "name": "filter_wave_mom", "description": null}, {"default": ".TRUE.", "units": null, "type_": "logical", "name": "write_a_restart", "description": null}, {"default": ".FALSE.", "units": null, "type_": "logical", "name": "use_this_module", "description": null}, {"default": ".TRUE.", "units": null, "type_": "logical", "name": "use_TMA", "description": null}], "filename": "src/mom5/ocean_wave/ocean_wave.F90"}]}]